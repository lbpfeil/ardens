---
phase: 07-fundacao-de-dados
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - database/schema.sql
  - arden/lib/supabase/actions/bulk-verificar.ts
autonomous: true

must_haves:
  truths:
    - "RPC bulk_verificar existe no banco e pode ser chamada via supabase.rpc()"
    - "RPC cria verificacoes + itens em transacao atomica para multiplos pares servico/unidade"
    - "RPC ignora celulas ja Conformes (travadas)"
    - "RPC aplica reinspecao em celulas com NC existente"
    - "RPC valida autorizacao via auth.uid() e acesso a obra"
    - "RPC retorna contagem de criados, ignorados e reinspecionados"
    - "Server Action wrapper valida input com Zod e chama o RPC"
    - "Migration aplicada via mcp__supabase__apply_migration"
    - "database/schema.sql atualizado com a funcao"
  artifacts:
    - path: "database/schema.sql"
      provides: "Documentacao da funcao bulk_verificar"
      contains: "bulk_verificar"
    - path: "arden/lib/supabase/actions/bulk-verificar.ts"
      provides: "Server Action wrapper para o RPC bulk_verificar"
      exports: ["bulkVerificar"]
  key_links:
    - from: "arden/lib/supabase/actions/bulk-verificar.ts"
      to: "PostgreSQL bulk_verificar function"
      via: "supabase.rpc('bulk_verificar', ...)"
      pattern: "supabase\\.rpc\\('bulk_verificar'"
    - from: "arden/lib/supabase/actions/bulk-verificar.ts"
      to: "@/lib/supabase/server"
      via: "import createClient"
      pattern: "import.*createClient.*from.*@/lib/supabase/server"
    - from: "arden/lib/supabase/actions/bulk-verificar.ts"
      to: "@/lib/validations/verificacao"
      via: "import ActionResult type"
      pattern: "import.*ActionResult.*from.*@/lib/validations/verificacao"
---

<objective>
Criar a funcao PostgreSQL `bulk_verificar` para operacoes de verificacao em massa e o Server Action wrapper que a chama.

Purpose: Fornece atomicidade para verificacoes em lote -- criando verificacoes + itens em transacao unica sem registros parciais. Cobre requisito DADOS-03.
Output: 1 migration PostgreSQL aplicada via MCP + 1 arquivo Server Action wrapper.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-fundacao-de-dados/07-CONTEXT.md
@.planning/phases/07-fundacao-de-dados/07-RESEARCH.md
@.planning/phases/07-fundacao-de-dados/07-01-SUMMARY.md

@database/schema.sql
@database/rls-policies.sql
@arden/lib/supabase/server.ts
@arden/lib/validations/verificacao.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Criar e aplicar migration da funcao bulk_verificar</name>
  <files>database/schema.sql</files>
  <action>
PRIMEIRO: Buscar o project_id do Supabase usando `mcp__supabase__list_projects`.

SEGUNDO: Verificar migrations existentes com `mcp__supabase__list_migrations`.

TERCEIRO: Aplicar migration via `mcp__supabase__apply_migration` com:
- name: `create_bulk_verificar_rpc`
- query: A funcao PL/pgSQL descrita abaixo

A funcao `bulk_verificar` deve:

**Assinatura:**
```sql
CREATE OR REPLACE FUNCTION bulk_verificar(
  p_obra_id UUID,
  p_resultado TEXT,       -- 'conforme' | 'nao_conforme' | 'excecao'
  p_pares JSONB,          -- [{"servico_id": "...", "unidade_id": "..."}, ...]
  p_descricao TEXT DEFAULT NULL  -- descricao opcional para o lote
) RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
```

**Logica interna:**

1. **Autorizacao:**
   - Obter `v_user_id := auth.uid()`. Se NULL, RAISE EXCEPTION 'Usuario nao autenticado'
   - Verificar acesso a obra: `SELECT 1 FROM usuario_obras WHERE usuario_id = v_user_id AND obra_id = p_obra_id`. Se nao existe, RAISE EXCEPTION 'Usuario nao tem acesso a esta obra'

2. **Validacao:**
   - Se `p_resultado` NOT IN ('conforme', 'nao_conforme', 'excecao'), RAISE EXCEPTION
   - Se `jsonb_array_length(p_pares) > 500`, RAISE EXCEPTION 'Limite de 500 pares por operacao' (batch safety)

3. **Mapear resultado para status de item:**
   - 'conforme' -> 'conforme'::status_inspecao
   - 'nao_conforme' -> 'nao_conforme'::status_inspecao
   - 'excecao' -> 'excecao'::status_inspecao

4. **Loop pelos pares** (`FOR v_par IN SELECT * FROM jsonb_array_elements(p_pares)`):

   a. Extrair `v_servico_id` e `v_unidade_id` do par JSON

   b. Buscar verificacao existente:
      ```sql
      SELECT id, status INTO v_verificacao_id, v_existing_status
      FROM verificacoes
      WHERE unidade_id = v_unidade_id AND servico_id = v_servico_id;
      ```

   c. **Se verificacao existe:**
      - Se `v_existing_status = 'concluida'`: incrementar `v_count_skipped`, CONTINUE (Conforme travada)
      - Se `v_existing_status = 'com_nc'`: REINSPECAO
        - Se `p_resultado = 'conforme'`: atualizar todos itens com `status_reinspecao = 'conforme_apos_reinspecao'`, `data_reinspecao = NOW()`, `inspetor_reinspecao_id = v_user_id`, `ciclos_reinspecao = ciclos_reinspecao + 1`
        - Se `p_resultado = 'nao_conforme'`: atualizar todos itens com `status_reinspecao = 'reprovado_apos_retrabalho'`, `data_reinspecao = NOW()`, etc.
        - Incrementar `v_count_reinspected`
      - Se `v_existing_status IN ('pendente', 'em_andamento')`: atualizar todos itens existentes com o novo status:
        ```sql
        UPDATE itens_verificacao
        SET status = v_item_status,
            data_inspecao = NOW(),
            inspetor_id = v_user_id
        WHERE verificacao_id = v_verificacao_id;
        ```
        Incrementar `v_count_created`

   d. **Se verificacao NAO existe:**
      - Inserir nova verificacao:
        ```sql
        INSERT INTO verificacoes (obra_id, unidade_id, servico_id, inspetor_id, data_inicio)
        VALUES (p_obra_id, v_unidade_id, v_servico_id, v_user_id, NOW())
        RETURNING id INTO v_verificacao_id;
        ```
      - Inserir itens a partir do template:
        ```sql
        INSERT INTO itens_verificacao (verificacao_id, item_servico_id, status, inspetor_id, data_inspecao)
        SELECT v_verificacao_id, is2.id, v_item_status, v_user_id, NOW()
        FROM itens_servico is2
        WHERE is2.servico_id = v_servico_id
        ORDER BY is2.ordem;
        ```
      - Incrementar `v_count_created`

5. **Retorno:**
   ```sql
   RETURN jsonb_build_object(
     'created', v_count_created,
     'skipped', v_count_skipped,
     'reinspected', v_count_reinspected
   );
   ```

NOTAS IMPORTANTES:
- A funcao e SECURITY DEFINER -- roda como owner do banco, bypassa RLS. A autorizacao e feita DENTRO da funcao.
- O trigger `tr_itens_verificacao_contadores` roda PER ROW apos cada INSERT/UPDATE em itens_verificacao. Para tamanhos tipicos de construcao (50 verificacoes * 10 itens = 500 triggers), isso e aceitavel. NAO desabilitar o trigger.
- A funcao inteira roda numa unica transacao automaticamente (Supabase/PostgREST wraps RPC calls in transactions).

QUARTO: Apos aplicar migration, atualizar `database/schema.sql` adicionando a funcao `bulk_verificar` na secao de funcoes (antes dos triggers, ou criar secao "Functions" se nao existir). Adicionar comentario explicando que esta funcao e SECURITY DEFINER e faz autorizacao interna.

QUINTO: Verificar que a migration foi aplicada com `mcp__supabase__execute_sql`:
```sql
SELECT proname, prosrc FROM pg_proc WHERE proname = 'bulk_verificar';
```
  </action>
  <verify>
`mcp__supabase__execute_sql` com query `SELECT proname FROM pg_proc WHERE proname = 'bulk_verificar'` retorna 1 resultado.
`database/schema.sql` contem a definicao da funcao `bulk_verificar`.
  </verify>
  <done>Funcao PostgreSQL `bulk_verificar` criada via migration, documentada em schema.sql, aceitando obra_id + resultado + pares JSON, com autorizacao interna, logica de conflito (skip Conforme, reinspecao NC), e retorno de contagens.</done>
</task>

<task type="auto">
  <name>Task 2: Criar Server Action wrapper para bulk_verificar</name>
  <files>arden/lib/supabase/actions/bulk-verificar.ts</files>
  <action>
Criar arquivo `arden/lib/supabase/actions/bulk-verificar.ts` com diretiva `'use server'`.

Importar de `@/lib/supabase/server` (NAO client).

Importar `ActionResult` de `@/lib/validations/verificacao` (criado no Plan 01, que e pre-requisito -- Wave 1).

Criar schema Zod para validacao do input:

```typescript
const bulkVerificarSchema = z.object({
  obra_id: z.string().uuid(),
  resultado: z.enum(['conforme', 'nao_conforme', 'excecao']),
  pares: z.array(z.object({
    servico_id: z.string().uuid(),
    unidade_id: z.string().uuid(),
  })).min(1, 'Selecione pelo menos um par servico/unidade').max(500, 'Maximo de 500 pares por operacao'),
  descricao: z.string().max(1000).optional(),
})
```

Implementar a Server Action:

```typescript
export async function bulkVerificar(input: z.infer<typeof bulkVerificarSchema>): Promise<ActionResult<BulkVerificarResult>> {
  // 1. Validar input
  const parsed = bulkVerificarSchema.safeParse(input)
  if (!parsed.success) {
    return { error: 'Dados invalidos' }
  }

  // 2. Chamar RPC
  const supabase = await createClient()
  const { data, error } = await supabase.rpc('bulk_verificar', {
    p_obra_id: parsed.data.obra_id,
    p_resultado: parsed.data.resultado,
    p_pares: parsed.data.pares,
    p_descricao: parsed.data.descricao ?? null,
  })

  if (error) {
    return { error: `Erro na verificacao em massa: ${error.message}` }
  }

  // 3. Revalidar
  revalidatePath(`/app/obras/${parsed.data.obra_id}`)

  return { data: data as BulkVerificarResult }
}
```

Definir o type de retorno:
```typescript
interface BulkVerificarResult {
  created: number
  skipped: number
  reinspected: number
}
```
  </action>
  <verify>
Executar `cd arden && npx tsc --noEmit` -- compila sem erros.
Verificar que arquivo tem `'use server'` na primeira linha.
Verificar que importa de `@/lib/supabase/server`.
Verificar que importa `ActionResult` de `@/lib/validations/verificacao`.
Verificar export: `grep "export async function bulkVerificar" arden/lib/supabase/actions/bulk-verificar.ts` retorna match.
  </verify>
  <done>Server Action `bulkVerificar` exportada, validando input com Zod (max 500 pares), chamando RPC `bulk_verificar`, e retornando contagem de criados/ignorados/reinspecionados. Importa ActionResult do Plan 01.</done>
</task>

</tasks>

<verification>
1. `mcp__supabase__execute_sql` confirma que funcao `bulk_verificar` existe no banco
2. `database/schema.sql` documenta a funcao
3. `arden/lib/supabase/actions/bulk-verificar.ts` existe com `'use server'`
4. `cd arden && npx tsc --noEmit` passa sem erros
5. Schema Zod valida que pares tem min 1, max 500 elementos
6. ActionResult importado de `@/lib/validations/verificacao` (sem duplicacao local)
</verification>

<success_criteria>
- RPC PostgreSQL `bulk_verificar` funcional e aplicada via migration MCP
- Transacao atomica -- erro em qualquer passo faz rollback completo
- Celulas Conformes (concluida) sao ignoradas no bulk
- Celulas com NC recebem reinspecao automatica
- Novas verificacoes criam itens a partir do template do servico
- Server Action wrapper com validacao Zod e retorno ActionResult (importado do Plan 01)
- Limite de 500 pares por operacao implementado
</success_criteria>

<output>
After completion, create `.planning/phases/07-fundacao-de-dados/07-02-SUMMARY.md`
</output>
