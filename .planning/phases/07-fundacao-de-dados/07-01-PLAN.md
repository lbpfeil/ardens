---
phase: 07-fundacao-de-dados
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - arden/lib/validations/verificacao.ts
  - arden/lib/supabase/actions/verificacoes.ts
  - arden/lib/supabase/actions/itens-verificacao.ts
autonomous: true

must_haves:
  truths:
    - "Server Action cria verificacao para um par servico/unidade com itens preenchidos automaticamente"
    - "Server Action atualiza resultado de verificacao (Conforme/NC/Excecao)"
    - "Server Action altera status de verificacao"
    - "Server Action marca item individual como C/NC/NA e trigger atualiza contadores"
    - "Verificacao Conforme e travada -- actions rejeitam atualizacao"
    - "Todas as actions validam input com Zod antes de executar"
    - "Todas as actions retornam formato consistente { data } ou { error }"
  artifacts:
    - path: "arden/lib/validations/verificacao.ts"
      provides: "Zod schemas para validacao de inputs das actions"
      contains: "criarVerificacaoSchema"
    - path: "arden/lib/supabase/actions/verificacoes.ts"
      provides: "Server Actions para CRUD de verificacoes"
      exports: ["criarVerificacao", "atualizarResultadoVerificacao", "atualizarStatusVerificacao"]
    - path: "arden/lib/supabase/actions/itens-verificacao.ts"
      provides: "Server Actions para CRUD de itens de verificacao"
      exports: ["marcarItemVerificacao", "marcarItemReinspecao"]
  key_links:
    - from: "arden/lib/supabase/actions/verificacoes.ts"
      to: "@/lib/supabase/server"
      via: "import createClient"
      pattern: "import.*createClient.*from.*@/lib/supabase/server"
    - from: "arden/lib/supabase/actions/verificacoes.ts"
      to: "@/lib/validations/verificacao"
      via: "import Zod schemas"
      pattern: "import.*Schema.*from.*@/lib/validations/verificacao"
    - from: "arden/lib/supabase/actions/itens-verificacao.ts"
      to: "@/lib/supabase/server"
      via: "import createClient"
      pattern: "import.*createClient.*from.*@/lib/supabase/server"
---

<objective>
Criar Server Actions para CRUD de verificacoes e itens de verificacao, introduzindo o padrao `'use server'` no projeto pela primeira vez.

Purpose: Fornece a camada de escrita (mutations) para verificacoes, pronta para qualquer UI consumir. Cobre requisitos DADOS-01 e DADOS-02.
Output: 3 arquivos -- schemas Zod, actions de verificacoes, actions de itens.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-fundacao-de-dados/07-CONTEXT.md
@.planning/phases/07-fundacao-de-dados/07-RESEARCH.md

@arden/lib/supabase/server.ts
@arden/lib/supabase/queries/servicos.ts
@arden/lib/validations/servico.ts
@arden/lib/validations/common.ts
@database/schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Criar schemas Zod para validacao de verificacoes</name>
  <files>arden/lib/validations/verificacao.ts</files>
  <action>
Criar arquivo `arden/lib/validations/verificacao.ts` seguindo o padrao existente de `servico.ts` e usando helpers de `common.ts`.

Schemas necessarios:

1. `criarVerificacaoSchema` -- valida input para criar verificacao:
   - `obra_id`: UUID obrigatorio (usar `uuidString()` de common.ts)
   - `unidade_id`: UUID obrigatorio
   - `servico_id`: UUID obrigatorio

2. `atualizarResultadoSchema` -- valida input para atualizar resultado:
   - `verificacao_id`: UUID obrigatorio
   - `resultado`: enum `'conforme' | 'nao_conforme' | 'excecao'`
   - `descricao`: string opcional (max 1000 chars)

3. `atualizarStatusSchema` -- valida input para alterar status:
   - `verificacao_id`: UUID obrigatorio
   - `status`: enum `'pendente' | 'em_andamento' | 'concluida' | 'com_nc'`

4. `marcarItemSchema` -- valida input para marcar item individual:
   - `item_verificacao_id`: UUID obrigatorio
   - `status`: enum `'conforme' | 'nao_conforme' | 'excecao'` (status_inspecao sem 'nao_verificado')
   - `observacao`: string opcional (max 1000 chars)

   IMPORTANTE: Na UI o usuario ve "C / NC / NA" (Nao se Aplica), mas no banco o enum `status_inspecao` usa `'excecao'` para representar NA. O mapeamento e:
   - C (Conforme) -> 'conforme'
   - NC (Nao Conforme) -> 'nao_conforme'
   - NA (Nao se Aplica) -> 'excecao'
   Adicionar comentario no schema documentando este mapeamento.

5. `marcarItemReinspecaoSchema` -- valida input para reinspecao de item:
   - `item_verificacao_id`: UUID obrigatorio
   - `status_reinspecao`: enum `'conforme_apos_reinspecao' | 'retrabalho' | 'aprovado_com_concessao' | 'reprovado_apos_retrabalho'`
   - `observacao_reinspecao`: string opcional (max 1000 chars)

Tambem exportar o type `ActionResult<T>` generico:
```typescript
export type ActionResult<T> =
  | { data: T; error?: never }
  | { error: string; data?: never }
```

Exportar os inferred types de cada schema (ex: `CriarVerificacaoInput`).

Usar mensagens de erro em portugues com acentuacao correta, consistente com `common.ts`.
  </action>
  <verify>
Executar `cd arden && npx tsc --noEmit` -- arquivo compila sem erros.
Verificar que todos os schemas exportam corretamente via: `grep -c "export const" arden/lib/validations/verificacao.ts` deve retornar 5.
  </verify>
  <done>5 schemas Zod e 1 type ActionResult exportados, compilando sem erros TypeScript. Mapeamento NA->excecao documentado em comentario no marcarItemSchema.</done>
</task>

<task type="auto">
  <name>Task 2: Criar Server Actions para verificacoes</name>
  <files>arden/lib/supabase/actions/verificacoes.ts</files>
  <action>
Criar diretorio `arden/lib/supabase/actions/` e arquivo `verificacoes.ts` com diretiva `'use server'` no topo.

IMPORTANTE: Este e o PRIMEIRO arquivo 'use server' do projeto. Seguir cuidadosamente:
- Importar `createClient` de `@/lib/supabase/server` (NAO de `@/lib/supabase/client`)
- Importar `revalidatePath` de `next/cache`
- Importar schemas de `@/lib/validations/verificacao`
- Retornar SEMPRE `ActionResult<T>` -- nunca throw errors

Actions a implementar:

1. `criarVerificacao(input)`:
   - Validar com `criarVerificacaoSchema`
   - Inserir na tabela `verificacoes` com status 'pendente', data_inicio = NOW
   - Se erro 23505 (unique violation): retornar erro amigavel "Ja existe uma verificacao para este servico/unidade"
   - Apos criar verificacao, buscar itens_servico do servico (`.from('itens_servico').select('id').eq('servico_id', ...).order('ordem')`)
   - Inserir itens_verificacao para TODOS os itens_servico encontrados, com status 'nao_verificado'
   - EDGE CASE: Se o servico tem zero itens_servico, criar a verificacao mesmo assim com total_itens=0. O trigger `atualizar_contadores_verificacao` cuida dos contadores automaticamente. Uma verificacao sem itens e valida (o servico pode ainda nao ter itens configurados).
   - `revalidatePath(\`/app/obras/\${input.obra_id}\`)`
   - Retornar `{ data: { id: verificacao.id } }`

2. `atualizarResultadoVerificacao(input)`:
   - Validar com `atualizarResultadoSchema`
   - PRIMEIRO: buscar verificacao atual para checar imutabilidade
   - Se status = 'concluida' E todos itens conforme: retornar `{ error: 'Verificacao Conforme e travada e nao pode ser alterada' }`
   - Se resultado = 'excecao': atualizar verificacao com descricao fornecida (campo de descricao na verificacao -- usar campo `observacao` se existir, ou armazenar na descricao)
   - Para resultado conforme/nao_conforme: a UI de verificacao individual (Fase 8) e quem marca itens individualmente. Esta action so atualiza o resultado se necessario para fluxo manual
   - `revalidatePath` no caminho da obra
   - Retornar `{ data: { id: verificacao_id } }`

3. `atualizarStatusVerificacao(input)`:
   - Validar com `atualizarStatusSchema`
   - Checar imutabilidade (mesma logica: concluida + conforme = travada)
   - Atualizar status na tabela verificacoes
   - `revalidatePath` no caminho da obra (buscar obra_id da verificacao)
   - Retornar `{ data: { id: verificacao_id } }`

Para buscar obra_id quando nao esta no input, fazer query:
```typescript
const { data: verif } = await supabase
  .from('verificacoes')
  .select('obra_id, status, itens_conformes, total_itens')
  .eq('id', verificacao_id)
  .single()
```

A logica de imutabilidade (Conforme travada): verificar se `verif.status === 'concluida'` E `verif.itens_conformes === verif.total_itens` E `verif.total_itens > 0`.

NAO tentar computar status/contadores manualmente -- o trigger `atualizar_contadores_verificacao()` faz isso automaticamente apos alteracoes em itens_verificacao.
  </action>
  <verify>
Executar `cd arden && npx tsc --noEmit` -- compila sem erros.
Verificar que arquivo tem `'use server'` na primeira linha.
Verificar que importa de `@/lib/supabase/server` (NAO client).
  </verify>
  <done>3 Server Actions exportadas (criarVerificacao, atualizarResultadoVerificacao, atualizarStatusVerificacao), todas com validacao Zod, retorno ActionResult, checagem de imutabilidade, e tratamento de edge case para servicos sem itens.</done>
</task>

<task type="auto">
  <name>Task 3: Criar Server Actions para itens de verificacao</name>
  <files>arden/lib/supabase/actions/itens-verificacao.ts</files>
  <action>
Criar arquivo `arden/lib/supabase/actions/itens-verificacao.ts` com diretiva `'use server'`.

Mesmas regras: importar de `@/lib/supabase/server`, retornar `ActionResult<T>`, validar com Zod.

Actions a implementar:

1. `marcarItemVerificacao(input)`:
   - Validar com `marcarItemSchema`
   - PRIMEIRO: buscar o item atual com sua verificacao para checar imutabilidade:
     ```typescript
     const { data: item } = await supabase
       .from('itens_verificacao')
       .select('id, verificacao_id, verificacoes(obra_id, status, itens_conformes, total_itens)')
       .eq('id', input.item_verificacao_id)
       .single()
     ```
   - Se verificacao esta travada (concluida + todos conforme): retornar erro
   - Atualizar item com:
     - `status`: o novo status
     - `observacao`: observacao do input (ou null)
     - `data_inspecao`: `new Date().toISOString()`
   - O trigger `atualizar_contadores_verificacao` roda automaticamente apos o update e recalcula os contadores da verificacao
   - `revalidatePath` no caminho da obra
   - Retornar `{ data: { id: item_verificacao_id } }`

2. `marcarItemReinspecao(input)`:
   - Validar com `marcarItemReinspecaoSchema`
   - Buscar item atual para checar se item realmente esta com status 'nao_conforme' (pre-condicao para reinspecao)
   - Se item.status != 'nao_conforme': retornar `{ error: 'Apenas itens Nao Conforme podem ser reinspecionados' }`
   - Atualizar item com:
     - `status_reinspecao`: o novo status de reinspecao
     - `observacao_reinspecao`: observacao do input (ou null)
     - `data_reinspecao`: `new Date().toISOString()`
     - `ciclos_reinspecao`: incrementar em 1 (`item.ciclos_reinspecao + 1`)
   - Nota: o trigger de contadores tambem recalcula apos update, incluindo a logica de NC com reinspecao
   - `revalidatePath` no caminho da obra
   - Retornar `{ data: { id: item_verificacao_id } }`

NOTA sobre o select com join: o Supabase retorna relacoes nested. O tipo de `verificacoes` no select sera um objeto, nao array, porque a relacao e many-to-one (cada item pertence a UMA verificacao). Acessar como `item.verificacoes.obra_id`.
  </action>
  <verify>
Executar `cd arden && npx tsc --noEmit` -- compila sem erros.
Verificar que arquivo tem `'use server'` na primeira linha.
Verificar que importa de `@/lib/supabase/server`.
Verificar que as 2 functions sao exportadas: `grep -c "export async function" arden/lib/supabase/actions/itens-verificacao.ts` deve retornar 2.
  </verify>
  <done>2 Server Actions exportadas (marcarItemVerificacao, marcarItemReinspecao), com validacao Zod, checagem de imutabilidade/pre-condicao, e delegacao de contadores ao trigger do banco.</done>
</task>

</tasks>

<verification>
1. `cd arden && npx tsc --noEmit` passa sem erros
2. Diretorio `arden/lib/supabase/actions/` existe com 2 arquivos
3. Arquivo `arden/lib/validations/verificacao.ts` existe com 5 schemas
4. Todos os 3 arquivos novos usam `'use server'` (actions) ou tipos corretos (validations)
5. Nenhum arquivo importa de `@/lib/supabase/client` -- apenas `@/lib/supabase/server`
</verification>

<success_criteria>
- 5 Server Actions funcionais (3 verificacoes + 2 itens) com validacao Zod
- Padrao 'use server' corretamente introduzido no projeto
- Tipo ActionResult<T> compartilhado para retorno consistente
- Imutabilidade de verificacao Conforme aplicada em todas as actions relevantes
- Criacao de verificacao automaticamente cria itens a partir do template do servico (ou cria com total_itens=0 se servico sem itens)
- Mapeamento NA->excecao documentado no schema
- Compilacao TypeScript sem erros
</success_criteria>

<output>
After completion, create `.planning/phases/07-fundacao-de-dados/07-01-SUMMARY.md`
</output>
