---
phase: 07-fundacao-de-dados
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - arden/lib/supabase/queries/verificacoes.ts
  - database/rls-policies.sql
autonomous: true

must_haves:
  truths:
    - "Query retorna servicos ativos da obra ordenados por categoria e nome"
    - "Query retorna unidades agrupadas por agrupamento com ordem preservada"
    - "Query retorna verificacoes existentes em formato Map para lookup O(1) por chave servico_id:unidade_id"
    - "Query executa 3 fetches em paralelo (Promise.all) para performance"
    - "Tipos TypeScript exportados para MatrizData, MatrizServico, MatrizAgrupamento, MatrizVerificacao"
    - "Queries de verificacoes executam em tempo aceitavel para obras com 500+ unidades"
  artifacts:
    - path: "arden/lib/supabase/queries/verificacoes.ts"
      provides: "Query otimizada para dados da matriz + tipos"
      exports: ["getMatrizData", "getVerificacaoComItens"]
    - path: "database/rls-policies.sql"
      provides: "Policies otimizadas com initPlan caching"
      contains: "SELECT get_user_cliente_id"
  key_links:
    - from: "arden/lib/supabase/queries/verificacoes.ts"
      to: "Supabase tables: obra_servicos, agrupamentos, verificacoes"
      via: "supabase.from().select()"
      pattern: "supabase.*from\\('(obra_servicos|agrupamentos|verificacoes)'\\)"
    - from: "arden/lib/supabase/queries/verificacoes.ts"
      to: "SupabaseClient parameter"
      via: "Accepts supabase client as parameter for server/client flexibility"
      pattern: "getMatrizData\\(supabase.*obraId"
---

<objective>
Criar query otimizada para alimentar a matriz de verificacoes e otimizar RLS policies existentes para performance em operacoes bulk.

Purpose: Fornece a camada de leitura (queries) para a matriz servico x unidade com lookup O(1), e garante que as policies RLS nao degradem performance em bulk. Cobre requisito DADOS-04.
Output: 1 arquivo de queries + policies RLS atualizadas.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-fundacao-de-dados/07-CONTEXT.md
@.planning/phases/07-fundacao-de-dados/07-RESEARCH.md

@arden/lib/supabase/client.ts
@arden/lib/supabase/server.ts
@arden/lib/supabase/queries/servicos.ts
@arden/lib/supabase/queries/obra-servicos.ts
@database/schema.sql
@database/rls-policies.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Criar query da matriz e query de verificacao individual</name>
  <files>arden/lib/supabase/queries/verificacoes.ts</files>
  <action>
Criar arquivo `arden/lib/supabase/queries/verificacoes.ts`.

IMPORTANTE - CONTEXTO DE CONSUMO: A funcao `getMatrizData` sera consumida tanto de Server Components (Fase 9, pagina da matriz) quanto potencialmente de Client Components. Para suportar ambos os contextos, a funcao deve ACEITAR o cliente Supabase como parametro em vez de importar diretamente de `@/lib/supabase/client` ou `@/lib/supabase/server`.

Isso permite que:
- Server Components passem `await createClient()` de `@/lib/supabase/server`
- Client Components passem `createClient()` de `@/lib/supabase/client`

NAO importar createClient neste arquivo. Receber como parametro.

**Tipos a exportar:**

```typescript
import { SupabaseClient } from '@supabase/supabase-js'

export interface MatrizServico {
  id: string
  codigo: string
  nome: string
  categoria: string | null
}

export interface MatrizUnidade {
  id: string
  nome: string
  codigo: string | null
  ordem: number
}

export interface MatrizAgrupamento {
  id: string
  nome: string
  ordem: number
  unidades: MatrizUnidade[]
}

export interface MatrizVerificacao {
  id: string
  unidade_id: string
  servico_id: string
  status: 'pendente' | 'em_andamento' | 'concluida' | 'com_nc'
  total_itens: number
  itens_verificados: number
  itens_conformes: number
  itens_nc: number
  itens_excecao: number
}

export interface MatrizData {
  servicos: MatrizServico[]
  agrupamentos: MatrizAgrupamento[]
  verificacoesMap: Record<string, MatrizVerificacao>  // chave: "servico_id:unidade_id"
}
```

**Funcao `getMatrizData(supabase: SupabaseClient, obraId: string): Promise<MatrizData>`:**

1. Executar 3 queries em paralelo com `Promise.all`:

   a. **Servicos ativos da obra:**
   ```typescript
   supabase
     .from('obra_servicos')
     .select('servico:servicos(id, codigo, nome, categoria)')
     .eq('obra_id', obraId)
     .eq('ativo', true)
   ```
   Depois mapear para extrair o servico nested e ordenar por categoria + nome.

   b. **Agrupamentos com unidades:**
   ```typescript
   supabase
     .from('agrupamentos')
     .select('id, nome, ordem, unidades(id, nome, codigo, ordem)')
     .eq('obra_id', obraId)
     .order('ordem', { ascending: true })
   ```
   Depois ordenar unidades dentro de cada agrupamento por `ordem`.

   c. **Verificacoes da obra:**
   ```typescript
   supabase
     .from('verificacoes')
     .select('id, unidade_id, servico_id, status, total_itens, itens_verificados, itens_conformes, itens_nc, itens_excecao')
     .eq('obra_id', obraId)
   ```

2. Construir o Map de lookup O(1):
   ```typescript
   const verificacoesMap: Record<string, MatrizVerificacao> = {}
   for (const v of verificacoesResult.data || []) {
     verificacoesMap[`${v.servico_id}:${v.unidade_id}`] = v
   }
   ```

3. Retornar `{ servicos, agrupamentos, verificacoesMap }`.

NOTA sobre o select com relacao nested em `obra_servicos`: Supabase retorna `{ servico: { id, codigo, nome, categoria } }`. Mapear para `MatrizServico[]` extraindo o campo `servico`.

NOTA sobre ordenacao de unidades: O Supabase `.order()` no nivel principal funciona, mas para ordenar unidades nested dentro de agrupamentos, precisa usar `supabase.from('agrupamentos').select('..., unidades(...)').order('ordem', { referencedTable: 'unidades', ascending: true })` OU ordenar em JavaScript apos o fetch. Verificar se o Supabase JS client v2.90 suporta `referencedTable` no order. Se nao, ordenar em JS:
```typescript
agrupamento.unidades.sort((a, b) => a.ordem - b.ordem)
```

**Funcao `getVerificacaoComItens(supabase: SupabaseClient, verificacaoId: string)`:**

Query auxiliar para a pagina de verificacao individual (sera usada na Fase 8). Tambem aceita supabase client como parametro, pelo mesmo motivo.

```typescript
export interface VerificacaoComItens {
  id: string
  obra_id: string
  unidade_id: string
  servico_id: string
  status: string
  total_itens: number
  itens_verificados: number
  itens_conformes: number
  itens_nc: number
  itens_excecao: number
  data_inicio: string | null
  data_conclusao: string | null
  created_at: string
  itens: ItemVerificacao[]
}

export interface ItemVerificacao {
  id: string
  item_servico_id: string
  status: string
  observacao: string | null
  data_inspecao: string | null
  status_reinspecao: string | null
  observacao_reinspecao: string | null
  data_reinspecao: string | null
  ciclos_reinspecao: number
  item_servico: {
    id: string
    descricao: string
    metodo_verificacao: string | null
    criterio_aceitacao: string | null
    tolerancia: string | null
    ordem: number
  }
}
```

```typescript
export async function getVerificacaoComItens(supabase: SupabaseClient, verificacaoId: string): Promise<VerificacaoComItens | null> {
  const { data, error } = await supabase
    .from('verificacoes')
    .select(`
      id, obra_id, unidade_id, servico_id, status,
      total_itens, itens_verificados, itens_conformes, itens_nc, itens_excecao,
      data_inicio, data_conclusao, created_at,
      itens_verificacao(
        id, item_servico_id, status, observacao, data_inspecao,
        status_reinspecao, observacao_reinspecao, data_reinspecao, ciclos_reinspecao,
        item_servico:itens_servico(id, descricao, metodo_verificacao, criterio_aceitacao, tolerancia, ordem)
      )
    `)
    .eq('id', verificacaoId)
    .single()

  if (error || !data) return null

  // Mapear e ordenar itens por ordem do item_servico
  const itens = (data.itens_verificacao || [])
    .map((iv: any) => ({
      ...iv,
      item_servico: iv.item_servico,
    }))
    .sort((a: any, b: any) => (a.item_servico?.ordem ?? 0) - (b.item_servico?.ordem ?? 0))

  return {
    ...data,
    itens,
  } as VerificacaoComItens
}
```

NOTA: Usar `any` no map/sort interno e aceitavel aqui porque o Supabase nao gera tipos para selects complexos com relacoes nested. O tipo de retorno da funcao e tipado corretamente via `VerificacaoComItens`.
  </action>
  <verify>
Executar `cd arden && npx tsc --noEmit` -- compila sem erros.
Verificar que `getMatrizData` e `getVerificacaoComItens` sao exportadas.
Verificar que NAO importa de `@/lib/supabase/client` nem `@/lib/supabase/server` -- deve receber supabase como parametro.
Verificar assinatura: `grep "getMatrizData(supabase" arden/lib/supabase/queries/verificacoes.ts` deve retornar match.
  </verify>
  <done>2 funcoes de query exportadas: getMatrizData (3 fetches paralelos, lookup Map O(1)) e getVerificacaoComItens (verificacao com itens nested ordenados). Ambas aceitam SupabaseClient como parametro para flexibilidade server/client. Tipos MatrizData, MatrizServico, MatrizAgrupamento, MatrizVerificacao, VerificacaoComItens, ItemVerificacao exportados.</done>
</task>

<task type="auto">
  <name>Task 2: Otimizar RLS policies com initPlan pattern</name>
  <files>database/rls-policies.sql</files>
  <action>
PRIMEIRO: Buscar o project_id do Supabase usando `mcp__supabase__list_projects`.

SEGUNDO: Aplicar migration via `mcp__supabase__apply_migration` para atualizar as policies de `verificacoes` e `itens_verificacao` com o padrao initPlan.

RISCO DE CONCORRENCIA: Esta task faz DROP + CREATE de RLS policies. Se o Plan 01 (Wave 1) estiver executando simultaneamente e fazendo queries contra as tabelas `verificacoes` ou `itens_verificacao`, as queries podem falhar brevemente durante o DROP/CREATE. Na pratica isso e improvavel porque Plan 01 cria Server Actions (arquivos .ts) e nao executa queries reais durante a build. Mas se ocorrerem erros de "policy does not exist" durante execucao paralela, re-executar a migration resolve.

O initPlan pattern wrapa chamadas de funcao em `(SELECT fn())` para que o PostgreSQL cache o resultado per-statement em vez de reavaliar per-row. Isso e critico para performance em operacoes que tocam muitas linhas.

**Policies a otimizar (verificacoes):**

Para cada policy de verificacoes (SELECT, INSERT, UPDATE, DELETE), substituir:
- `get_user_cliente_id()` por `(SELECT get_user_cliente_id())`
- `is_admin()` por `(SELECT is_admin())`
- `is_admin_or_engenheiro()` por `(SELECT is_admin_or_engenheiro())`
- `auth.uid()` por `(SELECT auth.uid())`
- `user_has_obra_access(obra_id)` por `obra_id IN (SELECT obra_id FROM usuario_obras WHERE usuario_id = (SELECT auth.uid()))` -- esta funcao NAO pode ser cached com initPlan porque depende do valor da coluna obra_id, mas pode ser substituida por um subselect que e avaliado uma vez

Ler o arquivo `database/rls-policies.sql` atual para obter as policies exatas de verificacoes e itens_verificacao. Recriar com DROP POLICY IF EXISTS + CREATE POLICY usando a versao otimizada.

**A migration deve conter:**

```sql
-- Otimizar RLS policies de verificacoes e itens_verificacao com initPlan pattern
-- Isso melhora performance significativamente em operacoes bulk

-- verificacoes_select
DROP POLICY IF EXISTS "verificacoes_select" ON verificacoes;
CREATE POLICY "verificacoes_select" ON verificacoes
  FOR SELECT USING (
    obra_id IN (
      SELECT id FROM obras WHERE cliente_id = (SELECT get_user_cliente_id())
    )
    AND (
      (SELECT is_admin_or_engenheiro())
      OR inspetor_id = (SELECT auth.uid())
    )
    AND obra_id IN (
      SELECT obra_id FROM usuario_obras WHERE usuario_id = (SELECT auth.uid())
    )
  );

-- [Repetir para INSERT, UPDATE, DELETE com mesmo padrao]
-- [Repetir para itens_verificacao com mesmo padrao]
```

NOTA: As policies de itens_verificacao fazem join com verificacoes para acessar obra_id. Manter esse join mas aplicar initPlan nas funcoes:
```sql
CREATE POLICY "itens_verificacao_select" ON itens_verificacao
  FOR SELECT USING (
    verificacao_id IN (
      SELECT v.id FROM verificacoes v
      WHERE v.obra_id IN (
        SELECT id FROM obras WHERE cliente_id = (SELECT get_user_cliente_id())
      )
      AND (
        (SELECT is_admin_or_engenheiro())
        OR v.inspetor_id = (SELECT auth.uid())
      )
      AND v.obra_id IN (
        SELECT obra_id FROM usuario_obras WHERE usuario_id = (SELECT auth.uid())
      )
    )
  );
```

TERCEIRO: Atualizar `database/rls-policies.sql` para refletir as policies otimizadas. Substituir as policies de verificacoes e itens_verificacao pelas versoes otimizadas. Adicionar comentario explicando o padrao initPlan.

QUARTO: Verificar que as policies foram aplicadas com `mcp__supabase__execute_sql`:
```sql
SELECT polname, polqual FROM pg_policy WHERE polrelid = 'verificacoes'::regclass;
```
  </action>
  <verify>
`mcp__supabase__execute_sql` com query `SELECT polname FROM pg_policy WHERE polrelid = 'verificacoes'::regclass` retorna as 4 policies (select, insert, update, delete).
`database/rls-policies.sql` contem as versoes otimizadas com `(SELECT ...)` wrapping.
  </verify>
  <done>8 RLS policies (4 verificacoes + 4 itens_verificacao) atualizadas com initPlan pattern para caching per-statement. user_has_obra_access substituido por subselect direto. Documentacao em rls-policies.sql atualizada.</done>
</task>

</tasks>

<verification>
1. `cd arden && npx tsc --noEmit` passa sem erros
2. `arden/lib/supabase/queries/verificacoes.ts` existe com tipos e funcoes exportados
3. Funcoes getMatrizData e getVerificacaoComItens aceitam SupabaseClient como primeiro parametro
4. RLS policies de verificacoes e itens_verificacao usam `(SELECT fn())` pattern
5. `database/rls-policies.sql` reflete as policies otimizadas
6. Query da matriz usa Promise.all para 3 fetches paralelos
7. Map de verificacoes usa chave `servico_id:unidade_id` para O(1) lookup
</verification>

<success_criteria>
- getMatrizData aceita SupabaseClient como parametro e retorna servicos ativos, agrupamentos com unidades, e verificacoes em Map O(1)
- getVerificacaoComItens aceita SupabaseClient como parametro e retorna verificacao completa com itens ordenados por ordem do template
- 3 queries paralelas (Promise.all) para performance
- RLS policies otimizadas com initPlan caching (10-100x melhoria em bulk)
- Tipos TypeScript exportados para uso por UIs futuras (Fases 8-10)
- Queries de verificacoes executam em tempo aceitavel para obras com 500+ unidades
</success_criteria>

<output>
After completion, create `.planning/phases/07-fundacao-de-dados/07-03-SUMMARY.md`
</output>
