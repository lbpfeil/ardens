---
phase: 05.2-tags-revisao-condicional
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - database/schema.sql
  - database/rls-policies.sql
  - arden/lib/supabase/queries/tags.ts
  - arden/lib/supabase/queries/servicos.ts
  - arden/lib/supabase/queries/obra-servicos.ts
  - arden/lib/supabase/queries/itens-servico.ts
  - arden/lib/validations/tag.ts
autonomous: true

must_haves:
  truths:
    - "Tags table exists with nome, cor, ordem fields"
    - "primeira_ativacao_em field tracks first-ever activation"
    - "itens_servico can reference a tag via tag_id"
    - "Tags CRUD functions available in data layer"
  artifacts:
    - path: "arden/lib/supabase/queries/tags.ts"
      provides: "Tags CRUD operations"
      exports: ["listTags", "createTag", "updateTag", "updateTagsOrder"]
    - path: "arden/lib/validations/tag.ts"
      provides: "Tag form validation schema"
      exports: ["tagFormSchema", "TagFormData"]
  key_links:
    - from: "arden/lib/supabase/queries/obra-servicos.ts"
      to: "servicos.primeira_ativacao_em"
      via: "activateServico sets primeira_ativacao_em on first activation"
      pattern: "primeira_ativacao_em.*COALESCE"
---

<objective>
Create database schema changes and data access layer for tags and conditional revision.

Purpose: Foundation for tags system and conditional revision logic
Output: Schema migrations applied, data access functions ready for UI consumption
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05.2-tags-revisao-condicional/REQUIREMENTS.md
@.planning/phases/05.2-tags-revisao-condicional/05.2-RESEARCH.md
@arden/lib/supabase/queries/servicos.ts
@arden/lib/supabase/queries/obra-servicos.ts
@arden/lib/supabase/queries/itens-servico.ts
@database/schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema changes for tags and conditional revision</name>
  <files>database/schema.sql</files>
  <action>
Update schema.sql with:

1. Add `ordem` column to existing `tags` table:
```sql
-- Add ordem column to tags (for display ordering in itens table)
ALTER TABLE tags ADD COLUMN ordem INTEGER DEFAULT 0;
```

2. Add `primeira_ativacao_em` to `servicos` table:
```sql
-- Track first-ever activation for conditional revision
ALTER TABLE servicos ADD COLUMN primeira_ativacao_em TIMESTAMPTZ;
```

3. Add `tag_id` foreign key to `itens_servico` table:
```sql
-- Items can optionally belong to a tag
ALTER TABLE itens_servico ADD COLUMN tag_id UUID REFERENCES tags(id) ON DELETE SET NULL;
CREATE INDEX idx_itens_servico_tag ON itens_servico(tag_id);
```

Note: The tags table already exists in schema.sql for agrupamentos. We're extending it for itens_servico use.

Place these ALTER statements after the CREATE TABLE statements in the appropriate sections.
  </action>
  <verify>Read database/schema.sql and confirm all three additions are present: tags.ordem, servicos.primeira_ativacao_em, itens_servico.tag_id</verify>
  <done>Schema has ordem in tags, primeira_ativacao_em in servicos, tag_id in itens_servico</done>
</task>

<task type="auto">
  <name>Task 2: Create tags data access layer</name>
  <files>arden/lib/supabase/queries/tags.ts, arden/lib/validations/tag.ts</files>
  <action>
Create tags.ts following the servicos.ts pattern:

```typescript
// arden/lib/supabase/queries/tags.ts
import { createClient } from '@/lib/supabase/client'

export interface Tag {
  id: string
  cliente_id: string
  nome: string
  cor: string
  ordem: number
  created_at: string
}

export interface TagInsert {
  nome: string
  cor: string
}

export interface TagUpdate {
  nome?: string
  cor?: string
}

const DEV_CLIENTE_ID = 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'

// Preset colors for tag picker
export const TAG_COLORS = [
  '#3B82F6', // Blue
  '#10B981', // Green
  '#F59E0B', // Amber
  '#EF4444', // Red
  '#8B5CF6', // Purple
  '#EC4899', // Pink
  '#06B6D4', // Cyan
  '#F97316', // Orange
] as const

export async function listTags(): Promise<Tag[]> {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('tags')
    .select('*')
    .eq('cliente_id', DEV_CLIENTE_ID)
    .order('ordem', { ascending: true })

  if (error) throw new Error(`Erro ao listar tags: ${error.message}`)
  return data || []
}

export async function createTag(tag: TagInsert): Promise<Tag> {
  const supabase = createClient()

  // Get max ordem
  const { data: existing } = await supabase
    .from('tags')
    .select('ordem')
    .eq('cliente_id', DEV_CLIENTE_ID)
    .order('ordem', { ascending: false })
    .limit(1)

  const nextOrdem = (existing?.[0]?.ordem ?? -1) + 1

  const { data, error } = await supabase
    .from('tags')
    .insert({
      ...tag,
      cliente_id: DEV_CLIENTE_ID,
      ordem: nextOrdem,
    })
    .select()
    .single()

  if (error) {
    if (error.code === '23505') {
      throw new Error('Ja existe uma tag com este nome')
    }
    throw new Error(`Erro ao criar tag: ${error.message}`)
  }
  return data
}

export async function updateTag(id: string, updates: TagUpdate): Promise<Tag> {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('tags')
    .update(updates)
    .eq('id', id)
    .select()
    .single()

  if (error) {
    if (error.code === '23505') {
      throw new Error('Ja existe uma tag com este nome')
    }
    throw new Error(`Erro ao atualizar tag: ${error.message}`)
  }
  return data
}

export async function updateTagsOrder(orderedIds: string[]): Promise<void> {
  const supabase = createClient()
  const updates = orderedIds.map((id, index) =>
    supabase.from('tags').update({ ordem: index }).eq('id', id)
  )
  const results = await Promise.all(updates)
  const errors = results.filter(r => r.error)
  if (errors.length > 0) {
    throw new Error('Erro ao atualizar ordem das tags')
  }
}
```

Create tag.ts validation:
```typescript
// arden/lib/validations/tag.ts
import { z } from 'zod'
import { requiredString } from './common'

export const tagFormSchema = z.object({
  nome: requiredString(1, 50, 'Nome'),
  cor: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Cor deve ser um codigo hex valido'),
})

export type TagFormData = z.infer<typeof tagFormSchema>
```
  </action>
  <verify>Files exist and exports are correct: `grep -l "listTags\|createTag" arden/lib/supabase/queries/tags.ts` and `grep "tagFormSchema" arden/lib/validations/tag.ts`</verify>
  <done>Tags data access layer and validation schema created</done>
</task>

<task type="auto">
  <name>Task 3: Update servicos and obra-servicos for conditional revision</name>
  <files>arden/lib/supabase/queries/servicos.ts, arden/lib/supabase/queries/obra-servicos.ts, arden/lib/supabase/queries/itens-servico.ts</files>
  <action>
1. Update Servico interface in servicos.ts to include primeira_ativacao_em:
```typescript
export interface Servico {
  // ... existing fields
  primeira_ativacao_em: string | null  // Add this field
}
```

2. Add updateServico function for draft mode (no revision increment) - it may already exist, confirm it's usable for this purpose.

3. In obra-servicos.ts, modify activateServico to set primeira_ativacao_em on first activation:
```typescript
export async function activateServico(obraId: string, servicoId: string): Promise<ObraServico> {
  const supabase = createClient()

  // Get current servico (including primeira_ativacao_em)
  const { data: servico, error: servicoError } = await supabase
    .from('servicos')
    .select('revisao, primeira_ativacao_em')
    .eq('id', servicoId)
    .single()

  if (servicoError) throw new Error(`Erro ao buscar servico: ${servicoError.message}`)

  // Set primeira_ativacao_em if not already set (use COALESCE pattern for idempotency)
  if (!servico.primeira_ativacao_em) {
    await supabase
      .from('servicos')
      .update({ primeira_ativacao_em: new Date().toISOString() })
      .eq('id', servicoId)
      .is('primeira_ativacao_em', null) // Only update if still null (race condition safety)
  }

  // Upsert obra_servico (existing logic unchanged)
  // ... rest of function
}
```

4. Similarly update bulkActivateServicos to set primeira_ativacao_em for each service being activated for the first time.

5. Update ItemServico interface in itens-servico.ts:
```typescript
export interface ItemServico {
  // ... existing fields
  tag_id: string | null  // Add this field
}

export interface ItemServicoInsert {
  // ... existing fields
  tag_id?: string | null  // Add this field
}

export interface ItemServicoUpdate {
  // ... existing fields
  tag_id?: string | null  // Add this field
}
```

6. Ensure createItemServico and updateItemServico pass through tag_id.
  </action>
  <verify>
- `grep "primeira_ativacao_em" arden/lib/supabase/queries/servicos.ts` shows field in interface
- `grep "primeira_ativacao_em" arden/lib/supabase/queries/obra-servicos.ts` shows update logic
- `grep "tag_id" arden/lib/supabase/queries/itens-servico.ts` shows field in interfaces
  </verify>
  <done>Servico interface has primeira_ativacao_em, activateServico sets it on first activation, ItemServico has tag_id</done>
</task>

</tasks>

<verification>
1. Schema changes documented in database/schema.sql
2. Tags CRUD functions work: list, create, update, reorder
3. Servico.primeira_ativacao_em field accessible
4. activateServico sets primeira_ativacao_em on first activation
5. ItemServico.tag_id field accessible
</verification>

<success_criteria>
- database/schema.sql has ordem in tags, primeira_ativacao_em in servicos, tag_id in itens_servico
- arden/lib/supabase/queries/tags.ts exports listTags, createTag, updateTag, updateTagsOrder
- arden/lib/validations/tag.ts exports tagFormSchema
- arden/lib/supabase/queries/servicos.ts Servico interface has primeira_ativacao_em
- arden/lib/supabase/queries/obra-servicos.ts activateServico sets primeira_ativacao_em
- arden/lib/supabase/queries/itens-servico.ts ItemServico interface has tag_id
</success_criteria>

<output>
After completion, create `.planning/phases/05.2-tags-revisao-condicional/05.2-01-SUMMARY.md`
</output>
