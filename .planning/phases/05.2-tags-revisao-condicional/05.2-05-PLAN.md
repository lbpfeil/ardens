---
phase: 05.2-tags-revisao-condicional
plan: 05
type: execute
wave: 4
depends_on: ["05.2-04"]
files_modified:
  - arden/app/app/biblioteca/[id]/_components/itens-servico-panel.tsx
  - arden/app/app/biblioteca/[id]/_components/tag-sections-reorder-modal.tsx
  - arden/lib/supabase/queries/itens-servico.ts
autonomous: true

must_haves:
  truths:
    - "User can drag an item from one tag to another"
    - "Dragging item between tags updates tag_id"
    - "User can reorder tag sections via modal"
    - "Dragging within same tag updates ordem"
  artifacts:
    - path: "arden/app/app/biblioteca/[id]/_components/itens-servico-panel.tsx"
      provides: "Drag-and-drop enabled items panel"
      min_lines: 150
    - path: "arden/app/app/biblioteca/[id]/_components/tag-sections-reorder-modal.tsx"
      provides: "Modal for reordering tag sections"
      min_lines: 80
  key_links:
    - from: "arden/app/app/biblioteca/[id]/_components/itens-servico-panel.tsx"
      to: "arden/lib/supabase/queries/itens-servico.ts"
      via: "calls updateItemServico for tag change, updateItensOrder for reorder"
      pattern: "updateItemServico\\|updateItensOrder"
    - from: "arden/app/app/biblioteca/[id]/_components/itens-servico-panel.tsx"
      to: "@dnd-kit/core"
      via: "DndContext for drag-and-drop"
      pattern: "DndContext"
---

<objective>
Implement drag-and-drop functionality for moving items between tags and reordering within tags.

Purpose: Allow engineers to visually organize items by dragging between tag sections
Output: Fully interactive drag-and-drop for items, plus modal for reordering tag sections
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05.2-tags-revisao-condicional/REQUIREMENTS.md
@.planning/phases/05.2-tags-revisao-condicional/05.2-RESEARCH.md
@arden/lib/supabase/queries/itens-servico.ts
@arden/lib/supabase/queries/tags.ts
@arden/app/app/biblioteca/[id]/_components/itens-servico-panel.tsx
@arden/app/app/obras/[id]/unidades/_components/agrupamentos-panel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add function to update item's tag</name>
  <files>arden/lib/supabase/queries/itens-servico.ts</files>
  <action>
Add a dedicated function for updating an item's tag (used when dragging between sections):

```typescript
/**
 * Atualiza a tag de um item de servico.
 * Usado quando arrastando item entre secoes de tags.
 */
export async function updateItemTag(id: string, tagId: string | null): Promise<ItemServico> {
  const supabase = createClient()

  const { data, error } = await supabase
    .from('itens_servico')
    .update({ tag_id: tagId })
    .eq('id', id)
    .select()
    .single()

  if (error) {
    throw new Error(`Erro ao atualizar tag do item: ${error.message}`)
  }

  return data
}

/**
 * Atualiza a tag e a ordem de um item de servico.
 * Usado quando arrastando item entre secoes de tags com posicionamento especifico.
 */
export async function updateItemTagAndOrder(
  id: string,
  tagId: string | null,
  ordem: number
): Promise<ItemServico> {
  const supabase = createClient()

  const { data, error } = await supabase
    .from('itens_servico')
    .update({ tag_id: tagId, ordem })
    .eq('id', id)
    .select()
    .single()

  if (error) {
    throw new Error(`Erro ao atualizar tag e ordem do item: ${error.message}`)
  }

  return data
}
```

Export these new functions from the file.
  </action>
  <verify>`grep "updateItemTag\|updateItemTagAndOrder" arden/lib/supabase/queries/itens-servico.ts` shows both functions</verify>
  <done>Functions for updating item tag and ordem are available</done>
</task>

<task type="auto">
  <name>Task 2: Add drag-and-drop to items panel</name>
  <files>arden/app/app/biblioteca/[id]/_components/itens-servico-panel.tsx</files>
  <action>
Enhance the itens-servico-panel.tsx with drag-and-drop using @dnd-kit:

```typescript
'use client'

import { useMemo, useState, useCallback } from 'react'
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
  type DragStartEvent,
  DragOverlay,
} from '@dnd-kit/core'
import {
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
  useSortable,
} from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'
import { Plus, ListChecks, MoreVertical, Trash2, GripVertical, ArrowUpDown } from 'lucide-react'
import { Button } from '@/components/ui/button'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import {
  updateItemTag,
  updateItensOrder,
  type ItemServico,
} from '@/lib/supabase/queries/itens-servico'
import { updateTagsOrder, type Tag } from '@/lib/supabase/queries/tags'
import type { Servico } from '@/lib/supabase/queries/servicos'
import { TagSectionsReorderModal } from './tag-sections-reorder-modal'
import { toast } from 'sonner'

// Sortable item row component
interface SortableItemRowProps {
  item: ItemServico
  onEditClick: (item: ItemServico) => void
  onDeleteClick: (item: ItemServico) => void
  isDragMode: boolean
}

function SortableItemRow({ item, onEditClick, onDeleteClick, isDragMode }: SortableItemRowProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: item.id })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  }

  return (
    <TableRow
      ref={setNodeRef}
      style={style}
      className={`group hover:bg-surface-200/50 ${isDragging ? 'opacity-50 bg-surface-200' : ''}`}
    >
      {isDragMode && (
        <TableCell className="w-[40px]">
          <button
            type="button"
            className="touch-none cursor-grab active:cursor-grabbing text-foreground-muted hover:text-foreground"
            {...attributes}
            {...listeners}
          >
            <GripVertical className="h-4 w-4" />
          </button>
        </TableCell>
      )}
      <TableCell className="text-foreground-muted">
        {item.ordem + 1}
      </TableCell>
      <TableCell>
        <p className="font-medium text-foreground max-w-[300px] truncate">
          {item.observacao}
        </p>
      </TableCell>
      <TableCell className="hidden md:table-cell">
        <p className="text-sm text-foreground-light max-w-[200px] truncate">
          {item.metodo || '-'}
        </p>
      </TableCell>
      {!isDragMode && (
        <TableCell>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="icon-sm">
                <MoreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem onClick={() => onEditClick(item)}>
                Editar
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem
                variant="destructive"
                onClick={() => onDeleteClick(item)}
              >
                <Trash2 className="h-4 w-4 mr-2" />
                Excluir
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </TableCell>
      )}
    </TableRow>
  )
}

interface ItensServicoPanelProps {
  servico: Servico
  itens: ItemServico[]
  tags: Tag[]
  onCreateClick: () => void
  onEditClick: (item: ItemServico) => void
  onDeleteClick: (item: ItemServico) => void
  onRefresh: () => void  // Add callback to refresh data
}

interface GroupedItems {
  tagId: string  // 'untagged' for items without tag
  tag: Tag | null
  items: ItemServico[]
}

export function ItensServicoPanel({
  servico,
  itens,
  tags,
  onCreateClick,
  onEditClick,
  onDeleteClick,
  onRefresh,
}: ItensServicoPanelProps) {
  const [isDragMode, setIsDragMode] = useState(false)
  const [isTagReorderModalOpen, setIsTagReorderModalOpen] = useState(false)
  const [activeId, setActiveId] = useState<string | null>(null)

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // Require 8px drag before activating
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  )

  // Group items by tag
  const groupedItems = useMemo((): GroupedItems[] => {
    const tagMap = new Map(tags.map(t => [t.id, t]))

    const untagged: ItemServico[] = []
    const byTag = new Map<string, ItemServico[]>()

    for (const item of itens) {
      if (!item.tag_id) {
        untagged.push(item)
      } else {
        const existing = byTag.get(item.tag_id) || []
        existing.push(item)
        byTag.set(item.tag_id, existing)
      }
    }

    const result: GroupedItems[] = []

    if (untagged.length > 0) {
      result.push({
        tagId: 'untagged',
        tag: null,
        items: untagged.sort((a, b) => a.ordem - b.ordem),
      })
    }

    const sortedTags = [...tags].sort((a, b) => a.ordem - b.ordem)
    for (const tag of sortedTags) {
      const tagItems = byTag.get(tag.id)
      if (tagItems && tagItems.length > 0) {
        result.push({
          tagId: tag.id,
          tag,
          items: tagItems.sort((a, b) => a.ordem - b.ordem),
        })
      }
    }

    return result
  }, [itens, tags])

  // Find which group an item belongs to
  const findItemGroup = useCallback((itemId: string): string | null => {
    for (const group of groupedItems) {
      if (group.items.some(i => i.id === itemId)) {
        return group.tagId
      }
    }
    return null
  }, [groupedItems])

  const handleDragStart = (event: DragStartEvent) => {
    setActiveId(event.active.id as string)
  }

  const handleDragEnd = async (event: DragEndEvent) => {
    const { active, over } = event
    setActiveId(null)

    if (!over) return

    const activeItemId = active.id as string
    const overItemId = over.id as string

    // Find source and destination groups
    const sourceGroupId = findItemGroup(activeItemId)
    const destGroupId = findItemGroup(overItemId)

    if (!sourceGroupId || !destGroupId) return

    // Same group - reorder within group
    if (sourceGroupId === destGroupId) {
      const group = groupedItems.find(g => g.tagId === sourceGroupId)
      if (!group) return

      const oldIndex = group.items.findIndex(i => i.id === activeItemId)
      const newIndex = group.items.findIndex(i => i.id === overItemId)

      if (oldIndex === newIndex) return

      // Calculate new order
      const newOrderedIds = [...group.items.map(i => i.id)]
      newOrderedIds.splice(oldIndex, 1)
      newOrderedIds.splice(newIndex, 0, activeItemId)

      try {
        await updateItensOrder(servico.id, newOrderedIds)
        onRefresh()
      } catch (error) {
        toast.error('Erro ao reordenar itens')
      }
    } else {
      // Different group - change tag
      const newTagId = destGroupId === 'untagged' ? null : destGroupId

      try {
        await updateItemTag(activeItemId, newTagId)
        onRefresh()
        toast.success('Item movido para outra tag')
      } catch (error) {
        toast.error('Erro ao mover item')
      }
    }
  }

  const handleTagsReorderSave = async (orderedTagIds: string[]) => {
    try {
      await updateTagsOrder(orderedTagIds)
      setIsTagReorderModalOpen(false)
      onRefresh()
      toast.success('Ordem das tags atualizada')
    } catch (error) {
      toast.error('Erro ao reordenar tags')
    }
  }

  const activeItem = activeId ? itens.find(i => i.id === activeId) : null

  // Empty state
  if (itens.length === 0) {
    return (
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-medium text-foreground">
            Itens de Verificacao
          </h2>
          <Button onClick={onCreateClick}>
            <Plus className="h-4 w-4 mr-1.5" data-icon="inline-start" />
            Novo Item
          </Button>
        </div>

        <div className="rounded-md border border-border bg-surface-100">
          <div className="flex flex-col items-center justify-center py-16 px-4 text-center">
            <ListChecks className="h-12 w-12 text-foreground-muted mb-4" />
            <p className="text-foreground-light mb-2">
              Nenhum item de verificacao cadastrado
            </p>
            <p className="text-sm text-foreground-muted mb-4">
              Adicione itens que definem o que verificar neste servico.
            </p>
            <Button onClick={onCreateClick} variant="outline" size="sm">
              <Plus className="h-4 w-4 mr-1.5" data-icon="inline-start" />
              Criar primeiro item
            </Button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-4">
      {/* Panel header */}
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-medium text-foreground">
          Itens de Verificacao
        </h2>
        <div className="flex items-center gap-2">
          {isDragMode ? (
            <Button variant="outline" onClick={() => setIsDragMode(false)}>
              Concluir
            </Button>
          ) : (
            <>
              {tags.length > 1 && (
                <Button variant="outline" onClick={() => setIsTagReorderModalOpen(true)}>
                  <ArrowUpDown className="h-4 w-4 mr-1.5" data-icon="inline-start" />
                  Reordenar Tags
                </Button>
              )}
              {itens.length > 1 && (
                <Button variant="outline" onClick={() => setIsDragMode(true)}>
                  <GripVertical className="h-4 w-4 mr-1.5" data-icon="inline-start" />
                  Organizar
                </Button>
              )}
              <Button onClick={onCreateClick}>
                <Plus className="h-4 w-4 mr-1.5" data-icon="inline-start" />
                Novo Item
              </Button>
            </>
          )}
        </div>
      </div>

      {/* Drag mode instruction */}
      {isDragMode && (
        <div className="flex items-center gap-2 p-3 rounded-md bg-surface-100 border border-border">
          <GripVertical className="h-4 w-4 text-foreground-muted" />
          <span className="text-sm text-foreground-light">
            Arraste itens para reordenar ou mover entre tags
          </span>
        </div>
      )}

      {/* Grouped items with DnD */}
      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
      >
        <div className="space-y-4">
          {groupedItems.map((group, groupIndex) => (
            <SortableContext
              key={group.tagId}
              items={group.items.map(i => i.id)}
              strategy={verticalListSortingStrategy}
            >
              <div className="rounded-md border border-border bg-surface-100 overflow-hidden">
                {/* Tag header (only for tagged groups) */}
                {group.tag && (
                  <div
                    className="flex items-center gap-2 px-3 py-2 border-b border-border"
                    style={{ borderLeftWidth: '3px', borderLeftColor: group.tag.cor }}
                  >
                    <span className="text-sm font-medium text-foreground">
                      {group.tag.nome}
                    </span>
                    <span className="text-xs text-foreground-muted">
                      ({group.items.length} {group.items.length === 1 ? 'item' : 'itens'})
                    </span>
                  </div>
                )}

                <Table>
                  {groupIndex === 0 && (
                    <TableHeader>
                      <TableRow>
                        {isDragMode && <TableHead className="w-[40px]"></TableHead>}
                        <TableHead className="w-[50px]">#</TableHead>
                        <TableHead>Observacao</TableHead>
                        <TableHead className="hidden md:table-cell">Metodo</TableHead>
                        {!isDragMode && <TableHead className="w-[50px]">Acoes</TableHead>}
                      </TableRow>
                    </TableHeader>
                  )}
                  <TableBody>
                    {group.items.map((item) => (
                      <SortableItemRow
                        key={item.id}
                        item={item}
                        onEditClick={onEditClick}
                        onDeleteClick={onDeleteClick}
                        isDragMode={isDragMode}
                      />
                    ))}
                  </TableBody>
                </Table>
              </div>
            </SortableContext>
          ))}
        </div>

        {/* Drag overlay */}
        <DragOverlay>
          {activeItem ? (
            <div className="bg-surface-100 border border-border rounded px-3 py-2 shadow-lg">
              <span className="text-sm font-medium text-foreground">
                {activeItem.observacao.slice(0, 50)}
                {activeItem.observacao.length > 50 ? '...' : ''}
              </span>
            </div>
          ) : null}
        </DragOverlay>
      </DndContext>

      {/* Tag sections reorder modal */}
      <TagSectionsReorderModal
        open={isTagReorderModalOpen}
        onOpenChange={setIsTagReorderModalOpen}
        tags={tags.filter(t => itens.some(i => i.tag_id === t.id))} // Only tags with items
        onSave={handleTagsReorderSave}
      />
    </div>
  )
}
```

Key features:
- "Organizar" button enters drag mode (hides actions, shows drag handles)
- Drag within same tag section = reorder
- Drag to different tag section = change tag_id
- DragOverlay shows item preview while dragging
- "Reordenar Tags" button opens modal for section order
  </action>
  <verify>
- `grep "DndContext" arden/app/app/biblioteca/[id]/_components/itens-servico-panel.tsx` shows DnD setup
- `grep "updateItemTag" arden/app/app/biblioteca/[id]/_components/itens-servico-panel.tsx` shows tag change on cross-group drag
- `grep "SortableItemRow" arden/app/app/biblioteca/[id]/_components/itens-servico-panel.tsx` shows sortable row component
  </verify>
  <done>Items panel has drag-and-drop for reordering and moving between tags</done>
</task>

<task type="auto">
  <name>Task 3: Create tag sections reorder modal</name>
  <files>arden/app/app/biblioteca/[id]/_components/tag-sections-reorder-modal.tsx, arden/app/app/biblioteca/[id]/_components/servico-detail-client.tsx</files>
  <action>
1. Create the tag sections reorder modal (similar to tags-reorder-modal but for service context):

```typescript
// arden/app/app/biblioteca/[id]/_components/tag-sections-reorder-modal.tsx
'use client'

import { useState, useEffect } from 'react'
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
} from '@dnd-kit/core'
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
  useSortable,
} from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { GripVertical } from 'lucide-react'
import type { Tag } from '@/lib/supabase/queries/tags'

interface SortableTagItemProps {
  tag: Tag
}

function SortableTagItem({ tag }: SortableTagItemProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: tag.id })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  }

  return (
    <li
      ref={setNodeRef}
      style={style}
      className={`flex items-center gap-3 px-3 py-2.5 bg-surface-100 border border-border rounded-md ${
        isDragging ? 'opacity-50' : ''
      }`}
    >
      <button
        type="button"
        className="touch-none cursor-grab active:cursor-grabbing text-foreground-muted hover:text-foreground"
        {...attributes}
        {...listeners}
      >
        <GripVertical className="h-4 w-4" />
      </button>
      <div
        className="h-4 w-4 rounded-sm flex-shrink-0"
        style={{ backgroundColor: tag.cor }}
      />
      <span className="text-foreground text-sm">{tag.nome}</span>
    </li>
  )
}

interface TagSectionsReorderModalProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  tags: Tag[]  // Only tags that have items in current service
  onSave: (orderedIds: string[]) => Promise<void>
}

export function TagSectionsReorderModal({
  open,
  onOpenChange,
  tags,
  onSave,
}: TagSectionsReorderModalProps) {
  const [pendingOrder, setPendingOrder] = useState<string[]>([])
  const [isSaving, setIsSaving] = useState(false)

  useEffect(() => {
    if (open) {
      setPendingOrder(tags.map(t => t.id))
    }
  }, [open, tags])

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  )

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event
    if (over && active.id !== over.id) {
      setPendingOrder((items) => {
        const oldIndex = items.indexOf(active.id as string)
        const newIndex = items.indexOf(over.id as string)
        return arrayMove(items, oldIndex, newIndex)
      })
    }
  }

  const handleSave = async () => {
    setIsSaving(true)
    try {
      await onSave(pendingOrder)
    } finally {
      setIsSaving(false)
    }
  }

  const orderedTags = pendingOrder
    .map(id => tags.find(t => t.id === id))
    .filter((t): t is Tag => t !== undefined)

  if (tags.length === 0) {
    return null
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[400px]">
        <DialogHeader>
          <DialogTitle>Reordenar Secoes de Tags</DialogTitle>
          <DialogDescription>
            Arraste para definir a ordem das secoes na tabela de itens.
          </DialogDescription>
        </DialogHeader>

        <DndContext
          sensors={sensors}
          collisionDetection={closestCenter}
          onDragEnd={handleDragEnd}
        >
          <SortableContext
            items={pendingOrder}
            strategy={verticalListSortingStrategy}
          >
            <ul className="space-y-2 max-h-[300px] overflow-y-auto py-2">
              {orderedTags.map((tag) => (
                <SortableTagItem key={tag.id} tag={tag} />
              ))}
            </ul>
          </SortableContext>
        </DndContext>

        <DialogFooter>
          <Button
            type="button"
            variant="outline"
            onClick={() => onOpenChange(false)}
            disabled={isSaving}
          >
            Cancelar
          </Button>
          <Button onClick={handleSave} disabled={isSaving}>
            {isSaving ? 'Salvando...' : 'Salvar Ordem'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

2. Update servico-detail-client.tsx to add onRefresh prop to ItensServicoPanel:

```typescript
// In ServicoDetailClient
const refreshItens = useCallback(async () => {
  const updated = await listItensServico(servico.id)
  setItens(updated)
}, [servico.id])

// Pass to panel
<ItensServicoPanel
  servico={servico}
  itens={itens}
  tags={tags}
  onCreateClick={() => setIsCreateModalOpen(true)}
  onEditClick={(item) => { setEditingItem(item) }}
  onDeleteClick={(item) => { setDeletingItem(item) }}
  onRefresh={refreshItens}  // Add this
/>
```

Also update the handleCreateSuccess and handleEditSuccess to use refreshItens instead of inline refetch.
  </action>
  <verify>
- `grep "TagSectionsReorderModal" arden/app/app/biblioteca/[id]/_components/tag-sections-reorder-modal.tsx` shows modal exists
- `grep "onRefresh" arden/app/app/biblioteca/[id]/_components/servico-detail-client.tsx` shows refresh callback passed
  </verify>
  <done>Tag sections reorder modal created, refresh callback wired up</done>
</task>

</tasks>

<verification>
1. Open service detail with items in different tags
2. Click "Organizar" - drag handles appear, actions hide
3. Drag item within same tag section - order updates
4. Drag item to different tag section - tag changes
5. Click "Reordenar Tags" - modal opens with tag list
6. Reorder tags in modal - section order changes in main view
7. Click "Concluir" - exit drag mode
</verification>

<success_criteria>
- "Organizar" button enters drag mode with visible drag handles
- Dragging item within tag reorders (ordem updates)
- Dragging item to different tag changes tag_id
- DragOverlay shows item preview while dragging
- "Reordenar Tags" modal allows section reordering
- Changes persist after refresh
</success_criteria>

<output>
After completion, create `.planning/phases/05.2-tags-revisao-condicional/05.2-05-SUMMARY.md`
</output>
