# Phase 5.2: Tags e Revisao Condicional - Research

**Researched:** 2026-01-23
**Domain:** Servico Revision Logic, Tags CRUD, Drag-and-Drop Grouping
**Confidence:** HIGH

## Summary

This phase requires two distinct features: conditional revision (only trigger revision increment when service has been activated) and a tags system for organizing verification items. The codebase already has strong patterns for both: the revision system from Phase 5.1 and drag-and-drop from Phase 3 (agrupamentos).

The existing `updateServicoWithRevision` function always creates a revision. The change requires adding a `primeira_ativacao_em` field to track if a service was ever activated, then conditionally calling either `updateServico` (no revision) or `updateServicoWithRevision` based on this field.

For tags, the schema already has a `tags` table but it's designed for agrupamentos (N:N relationship). Phase 5.2 requires a new purpose: tags for itens_servico with 1:N relationship (each item has one tag). The existing @dnd-kit setup provides reusable patterns for sortable lists and cross-container dragging.

**Primary recommendation:** Reuse existing patterns extensively - the revision logic needs minimal changes, and dnd-kit patterns from agrupamentos panel can be adapted for tagged items.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @dnd-kit/core | 6.3.1 | Drag-and-drop foundation | Already used in Phase 3 for agrupamentos |
| @dnd-kit/sortable | 10.0.0 | Sortable lists and grids | Reorderable items within tag groups |
| @dnd-kit/utilities | 3.2.2 | CSS transform utilities | Already installed |
| React Hook Form | 7.71.1 | Form management | Consistent with existing forms |
| Zod | 3.25.76 | Schema validation | Consistent with existing validation |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| sonner | 2.0.7 | Toast notifications | Success/error feedback |
| lucide-react | 0.562.0 | Icons | GripVertical for drag handles, Tag for tag indicators |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Native input[type=color] | react-colorful | Native is simpler, react-colorful has better UX but adds dependency |
| Preset color palette | Full color picker | Preset colors ensure visual consistency, simpler implementation |

**Installation:** No new packages needed - all dependencies already installed.

## Architecture Patterns

### Schema Changes Required

**1. Add `primeira_ativacao_em` to servicos table:**
```sql
-- Migration
ALTER TABLE servicos
ADD COLUMN primeira_ativacao_em TIMESTAMPTZ;

-- Update when first activation occurs (in activateServico function)
```

**2. Modify tags table for itens_servico:**
```sql
-- Current tags table is for agrupamentos (N:N)
-- Need to add `ordem` column for display ordering
ALTER TABLE tags ADD COLUMN ordem INTEGER DEFAULT 0;

-- Add tag_id to itens_servico
ALTER TABLE itens_servico ADD COLUMN tag_id UUID REFERENCES tags(id) ON DELETE SET NULL;
CREATE INDEX idx_itens_servico_tag ON itens_servico(tag_id);
```

**3. RLS for tags (follow servicos pattern):**
```sql
-- SELECT: All users of cliente see tags
DROP POLICY IF EXISTS "tags_select" ON tags;
CREATE POLICY "tags_select" ON tags
  FOR SELECT USING (cliente_id = get_user_cliente_id());

-- INSERT/UPDATE/DELETE: Admin only
DROP POLICY IF EXISTS "tags_insert" ON tags;
CREATE POLICY "tags_insert" ON tags
  FOR INSERT WITH CHECK (
    cliente_id = get_user_cliente_id() AND is_admin()
  );

DROP POLICY IF EXISTS "tags_update" ON tags;
CREATE POLICY "tags_update" ON tags
  FOR UPDATE USING (
    cliente_id = get_user_cliente_id() AND is_admin()
  );

-- No delete policy (REQ-02: cannot delete tags)
```

### Recommended Project Structure
```
arden/
├── lib/supabase/queries/
│   ├── tags.ts                    # NEW: Tags CRUD
│   └── itens-servico.ts           # MODIFY: Add tag_id support
├── lib/validations/
│   └── tag.ts                     # NEW: Tag form validation
├── app/app/tags/
│   ├── page.tsx                   # NEW: Tags list page
│   └── _components/
│       ├── tags-page-client.tsx   # NEW: Client component
│       ├── tag-form-modal.tsx     # NEW: Create/edit modal
│       └── tags-reorder-modal.tsx # NEW: DnD reorder modal
├── app/app/biblioteca/[id]/_components/
│   ├── itens-servico-panel.tsx    # MODIFY: Add tag grouping
│   ├── tagged-items-table.tsx     # NEW: Grouped table component
│   ├── item-servico-form-modal.tsx # MODIFY: Add tag selector
│   └── tag-reorder-modal.tsx      # NEW: Reorder tags for this view
```

### Pattern 1: Conditional Revision Decision
**What:** Decide whether to increment revision based on primeira_ativacao_em
**When to use:** Every servico edit
**Example:**
```typescript
// Source: Adapted from existing servicos.ts
export async function updateServicoSmart(
  id: string,
  updates: ServicoUpdate | ServicoUpdateWithRevision
): Promise<Servico> {
  const supabase = createClient()

  // Check if service has ever been activated
  const { data: servico } = await supabase
    .from('servicos')
    .select('primeira_ativacao_em')
    .eq('id', id)
    .single()

  if (servico?.primeira_ativacao_em) {
    // Service has been activated - require revision
    if (!('descricao_mudanca' in updates)) {
      throw new Error('Servico ja foi ativado, descricao_mudanca e obrigatoria')
    }
    return updateServicoWithRevision(id, updates as ServicoUpdateWithRevision)
  } else {
    // Never activated - simple update, no revision
    return updateServico(id, updates)
  }
}
```

### Pattern 2: Set primeira_ativacao_em on First Activation
**What:** Track first-ever activation timestamp
**When to use:** In activateServico function
**Example:**
```typescript
// Source: Adapted from obra-servicos.ts
export async function activateServico(obraId: string, servicoId: string): Promise<ObraServico> {
  const supabase = createClient()

  // Get current servico (including primeira_ativacao_em)
  const { data: servico, error: servicoError } = await supabase
    .from('servicos')
    .select('revisao, primeira_ativacao_em')
    .eq('id', servicoId)
    .single()

  if (servicoError) throw new Error(`Erro ao buscar servico: ${servicoError.message}`)

  // Set primeira_ativacao_em if not set
  if (!servico.primeira_ativacao_em) {
    await supabase
      .from('servicos')
      .update({ primeira_ativacao_em: new Date().toISOString() })
      .eq('id', servicoId)
  }

  // Upsert obra_servico (existing logic)
  const { data, error } = await supabase
    .from('obra_servicos')
    .upsert(
      {
        obra_id: obraId,
        servico_id: servicoId,
        ativo: true,
        revisao_ativa: servico.revisao || '00',
      },
      { onConflict: 'obra_id,servico_id' }
    )
    .select()
    .single()

  if (error) throw new Error(`Erro ao ativar servico: ${error.message}`)
  return data
}
```

### Pattern 3: DnD Context with Multiple Sortable Containers
**What:** Items grouped by tag, draggable between groups
**When to use:** Tagged items table
**Example:**
```typescript
// Source: Adapted from agrupamentos-panel.tsx
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
  type DragOverEvent,
} from '@dnd-kit/core'
import {
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable'

// For cross-container dragging, need to track active container
const [activeId, setActiveId] = useState<string | null>(null)
const [activeContainer, setActiveContainer] = useState<string | null>(null)

function handleDragStart(event: DragStartEvent) {
  const { active } = event
  setActiveId(active.id as string)
  // Find which tag group this item belongs to
  setActiveContainer(findContainer(active.id as string))
}

function handleDragOver(event: DragOverEvent) {
  const { active, over } = event
  if (!over) return

  const activeContainer = findContainer(active.id as string)
  const overContainer = findContainer(over.id as string)

  if (activeContainer !== overContainer) {
    // Move item to new container (update tag_id)
    moveItemToContainer(active.id as string, overContainer)
  }
}

function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event
  if (!over) return

  // Reorder within same container
  const activeContainer = findContainer(active.id as string)
  const overContainer = findContainer(over.id as string)

  if (activeContainer === overContainer) {
    reorderWithinContainer(activeContainer, active.id, over.id)
  }

  // Persist changes
  await saveItemOrder()
}
```

### Pattern 4: Color Picker with Preset Palette
**What:** Select tag color from predefined palette
**When to use:** Tag form modal
**Example:**
```typescript
// Preset colors that work well with dark theme
const TAG_COLORS = [
  '#3B82F6', // Blue
  '#10B981', // Green (brand-ish)
  '#F59E0B', // Amber
  '#EF4444', // Red
  '#8B5CF6', // Purple
  '#EC4899', // Pink
  '#06B6D4', // Cyan
  '#F97316', // Orange
] as const

interface ColorPickerProps {
  value: string
  onChange: (color: string) => void
}

function ColorPicker({ value, onChange }: ColorPickerProps) {
  return (
    <div className="flex flex-wrap gap-2">
      {TAG_COLORS.map((color) => (
        <button
          key={color}
          type="button"
          onClick={() => onChange(color)}
          className={cn(
            "h-8 w-8 rounded-md border-2 transition-all",
            value === color
              ? "border-foreground scale-110"
              : "border-transparent hover:scale-105"
          )}
          style={{ backgroundColor: color }}
        />
      ))}
    </div>
  )
}
```

### Anti-Patterns to Avoid
- **Separate update functions based on mode in UI:** Let the data layer decide, not the component
- **Storing tag order in items table:** Tags have their own `ordem`, items have their own `ordem` within each tag
- **Complex DnD with drag overlays immediately:** Start simple, add visual polish later
- **Custom color input instead of preset palette:** Preset colors ensure consistent visual design

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Sortable lists | Custom drag handlers | @dnd-kit/sortable | Already installed, battle-tested |
| Form validation | Manual validation | Zod + React Hook Form | Consistent with codebase |
| Toast notifications | Custom alert system | sonner | Already configured |
| Modal dialogs | Custom portal logic | shadcn Dialog | Consistent UX |
| Color selection | Complex color picker | Preset palette | Simpler, visually consistent |

**Key insight:** The codebase already has all patterns needed. This phase is about assembly, not invention.

## Common Pitfalls

### Pitfall 1: Forgetting to Check primeira_ativacao_em in Edit Modal
**What goes wrong:** Always showing "Descricao da Mudanca" field even for draft services
**Why it happens:** Current modal always shows the field in edit mode
**How to avoid:** Fetch servico with primeira_ativacao_em, conditionally render field
**Warning signs:** Draft services requiring revision description

### Pitfall 2: Race Condition on First Activation
**What goes wrong:** Multiple simultaneous activations could set primeira_ativacao_em multiple times
**Why it happens:** No transaction wrapping the check-and-set
**How to avoid:** Use COALESCE in single UPDATE: `UPDATE servicos SET primeira_ativacao_em = COALESCE(primeira_ativacao_em, NOW())`
**Warning signs:** primeira_ativacao_em changing after first set

### Pitfall 3: Tag Order vs Item Order Confusion
**What goes wrong:** Reordering tags changes item display incorrectly
**Why it happens:** Confusing `tags.ordem` (section order) with `itens_servico.ordem` (within section)
**How to avoid:** Clear naming: tagOrdem for sections, itemOrdem for items
**Warning signs:** Items jumping between sections unexpectedly

### Pitfall 4: DnD Not Working with Table Rows
**What goes wrong:** Table structure breaks drag-and-drop
**Why it happens:** HTML table semantics conflict with DnD transforms
**How to avoid:** Use div-based layout styled as table, or render drag handle separately
**Warning signs:** Broken layout during drag, items not dropping correctly

### Pitfall 5: Untagged Items Display
**What goes wrong:** Items without tags appear in wrong place or not at all
**Why it happens:** Grouping logic doesn't handle null tag_id
**How to avoid:** Explicit "untagged" group rendered first (per REQ-05)
**Warning signs:** Missing items after adding tag system

## Code Examples

Verified patterns from existing codebase:

### Tags Query File Structure
```typescript
// lib/supabase/queries/tags.ts
import { createClient } from '@/lib/supabase/client'

export interface Tag {
  id: string
  cliente_id: string
  nome: string
  cor: string
  ordem: number
  created_at: string
}

export interface TagInsert {
  nome: string
  cor: string
}

export interface TagUpdate {
  nome?: string
  cor?: string
}

// DEV_CLIENTE_ID pattern from servicos.ts
const DEV_CLIENTE_ID = 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'

export async function listTags(): Promise<Tag[]> {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('tags')
    .select('*')
    .order('ordem', { ascending: true })

  if (error) throw new Error(`Erro ao listar tags: ${error.message}`)
  return data || []
}

export async function createTag(tag: TagInsert): Promise<Tag> {
  const supabase = createClient()

  // Get max ordem
  const { data: existing } = await supabase
    .from('tags')
    .select('ordem')
    .eq('cliente_id', DEV_CLIENTE_ID)
    .order('ordem', { ascending: false })
    .limit(1)

  const nextOrdem = (existing?.[0]?.ordem ?? -1) + 1

  const { data, error } = await supabase
    .from('tags')
    .insert({
      ...tag,
      cliente_id: DEV_CLIENTE_ID,
      ordem: nextOrdem,
    })
    .select()
    .single()

  if (error) {
    if (error.code === '23505') {
      throw new Error('Ja existe uma tag com este nome')
    }
    throw new Error(`Erro ao criar tag: ${error.message}`)
  }
  return data
}

export async function updateTag(id: string, updates: TagUpdate): Promise<Tag> {
  const supabase = createClient()
  const { data, error } = await supabase
    .from('tags')
    .update(updates)
    .eq('id', id)
    .select()
    .single()

  if (error) throw new Error(`Erro ao atualizar tag: ${error.message}`)
  return data
}

export async function updateTagsOrder(orderedIds: string[]): Promise<void> {
  const supabase = createClient()
  const updates = orderedIds.map((id, index) =>
    supabase.from('tags').update({ ordem: index }).eq('id', id)
  )
  const results = await Promise.all(updates)
  const errors = results.filter(r => r.error)
  if (errors.length > 0) {
    throw new Error('Erro ao atualizar ordem das tags')
  }
}
```

### Item Form Modal with Tag Selector
```typescript
// Adapted from existing item-servico-form-modal.tsx
// Add tag selector using existing Select component

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'

// In form:
<div className="space-y-2">
  <Label htmlFor="tag_id">Tag</Label>
  <Select
    value={tagId || ''}
    onValueChange={(value) => setValue('tag_id', value || null)}
  >
    <SelectTrigger className="w-full">
      <SelectValue placeholder="Sem tag" />
    </SelectTrigger>
    <SelectContent>
      <SelectItem value="">Sem tag</SelectItem>
      {tags.map((tag) => (
        <SelectItem key={tag.id} value={tag.id}>
          <div className="flex items-center gap-2">
            <div
              className="h-3 w-3 rounded-sm"
              style={{ backgroundColor: tag.cor }}
            />
            {tag.nome}
          </div>
        </SelectItem>
      ))}
    </SelectContent>
  </Select>
</div>
```

### Servico Type Extension
```typescript
// In servicos.ts, add to Servico interface
export interface Servico {
  // ... existing fields
  primeira_ativacao_em: string | null  // NEW
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Always increment revision | Conditional based on activation | Phase 5.2 | Draft services can be freely edited |
| Items flat list | Items grouped by tags | Phase 5.2 | Better organization for complex services |

**Deprecated/outdated:**
- None for this phase - building on Phase 5.1 patterns

## Open Questions

Things that couldn't be fully resolved:

1. **Should tags be deletable if no items use them?**
   - What we know: REQ-02 says tags cannot be deleted
   - What's unclear: Is this to preserve audit trail or simplify logic?
   - Recommendation: Keep as-is (no delete), add "archived" flag later if needed

2. **Should item edits trigger revision like servico edits?**
   - What we know: REQ-01 focuses on servico edits
   - What's unclear: Does adding/removing/editing items count as "edit"?
   - Recommendation: For Phase 5.2, only servico field edits trigger revision. Item changes don't. Clarify with user if needed.

3. **Cross-servico tag sharing?**
   - What we know: Tags are per-cliente (global)
   - What's unclear: Will this cause confusion with many services?
   - Recommendation: Proceed with global tags. Can add servico-specific tags later if needed.

## Sources

### Primary (HIGH confidence)
- `arden/lib/supabase/queries/servicos.ts` - Current revision pattern
- `arden/lib/supabase/queries/obra-servicos.ts` - Activation logic
- `arden/lib/supabase/queries/itens-servico.ts` - Item CRUD pattern
- `arden/app/app/obras/[id]/unidades/_components/agrupamentos-panel.tsx` - DnD pattern
- `arden/app/app/biblioteca/[id]/_components/item-servico-form-modal.tsx` - Form modal pattern
- `database/schema.sql` - Current schema structure
- `database/rls-policies.sql` - RLS patterns

### Secondary (MEDIUM confidence)
- @dnd-kit official docs for cross-container drag patterns

### Tertiary (LOW confidence)
- None - all patterns verified from existing codebase

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already installed and used
- Architecture: HIGH - Patterns directly adapted from existing code
- Pitfalls: HIGH - Based on existing implementation experience

**Research date:** 2026-01-23
**Valid until:** 2026-02-23 (stable patterns, unlikely to change)
