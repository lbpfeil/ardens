---
phase: 02-obras
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - arden/components/ui/dialog.tsx
  - arden/components/ui/table.tsx
  - arden/components/ui/progress.tsx
  - arden/components/ui/skeleton.tsx
  - arden/components/ui/sonner.tsx
  - arden/app/layout.tsx
  - arden/lib/validations/obra.ts
  - arden/lib/supabase/queries/obras.ts
autonomous: true

must_haves:
  truths:
    - "shadcn Dialog, Table, Progress, Skeleton, Sonner components exist in codebase"
    - "Toaster component renders in root layout"
    - "Obra validation schema matches database schema (nome required, tipologia/cidade/estado optional)"
    - "Data access functions for obras exist and are typed"
  artifacts:
    - path: "arden/components/ui/dialog.tsx"
      provides: "Modal component for create/edit forms"
    - path: "arden/components/ui/table.tsx"
      provides: "Table components for obras list"
    - path: "arden/components/ui/sonner.tsx"
      provides: "Toast notification provider"
    - path: "arden/lib/validations/obra.ts"
      provides: "Updated Zod schema aligned with DB"
      contains: "tipologia"
    - path: "arden/lib/supabase/queries/obras.ts"
      provides: "CRUD operations for obras"
      exports: ["listObras", "getObra", "createObra", "updateObra", "archiveObra"]
  key_links:
    - from: "arden/app/layout.tsx"
      to: "sonner Toaster"
      via: "import and render in layout"
      pattern: "<Toaster"
---

<objective>
Setup infrastructure for Obras CRUD: install missing shadcn components, configure toast notifications, update obra validation schema to match database, and create typed data access layer.

Purpose: Foundation for all obras features - components, validation, and data access must exist before UI pages.
Output: Ready-to-use UI components, aligned validation schema, typed Supabase query functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-obras/02-RESEARCH.md
@.planning/phases/02-obras/02-CONTEXT.md
@database/schema.sql
@arden/lib/validations/obra.ts
@arden/lib/validations/common.ts
@arden/lib/supabase/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add missing shadcn components and configure Toaster</name>
  <files>
    arden/components/ui/dialog.tsx
    arden/components/ui/table.tsx
    arden/components/ui/progress.tsx
    arden/components/ui/skeleton.tsx
    arden/components/ui/sonner.tsx
    arden/app/layout.tsx
  </files>
  <action>
    Install missing shadcn components via CLI:
    ```bash
    cd arden && npx shadcn@latest add dialog table progress skeleton sonner
    ```

    After installation, add Toaster to root layout (arden/app/layout.tsx):
    - Import: `import { Toaster } from '@/components/ui/sonner'`
    - Add `<Toaster />` as last child inside body, before closing body tag
    - Toaster should be outside the StoreProvider (toast is global, not store-dependent)

    Note: sonner requires the Toaster component to be rendered once at app root for toast() calls to work anywhere.
  </action>
  <verify>
    - Files exist: `ls arden/components/ui/{dialog,table,progress,skeleton,sonner}.tsx`
    - Toaster in layout: `grep -l "Toaster" arden/app/layout.tsx`
    - Build passes: `cd arden && npm run build`
  </verify>
  <done>
    shadcn components Dialog, Table, Progress, Skeleton, Sonner exist in components/ui/ and Toaster renders in root layout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update obra validation schema to match database</name>
  <files>arden/lib/validations/obra.ts</files>
  <action>
    Update arden/lib/validations/obra.ts to align with database schema and CONTEXT.md decisions:

    Current schema has fields not in DB (endereco full, dataInicio). Database has:
    - nome (required, 3-255 chars)
    - codigo (optional, max 50)
    - tipologia (enum: residencial_horizontal, residencial_vertical, comercial, retrofit, misto)
    - cidade (optional, max 100)
    - estado (optional, exactly 2 chars UF)
    - responsavel_tecnico (optional, max 255)

    Replace existing schema with:

    ```typescript
    import { z } from 'zod'
    import { requiredString, optionalString } from './common'

    /**
     * Opcoes de tipologia de obra conforme enum do banco de dados.
     */
    export const tipologiaOptions = [
      { value: 'residencial_horizontal', label: 'Residencial Horizontal' },
      { value: 'residencial_vertical', label: 'Residencial Vertical' },
      { value: 'comercial', label: 'Comercial' },
      { value: 'retrofit', label: 'Retrofit' },
      { value: 'misto', label: 'Misto' },
    ] as const

    export type TipologiaObra = typeof tipologiaOptions[number]['value']

    /**
     * Schema de validacao para formulario de obra.
     * Alinhado com tabela obras no banco de dados.
     *
     * Campos obrigatorios: nome
     * Campos opcionais: codigo, tipologia, cidade, estado, responsavel_tecnico
     */
    export const obraFormSchema = z.object({
      nome: requiredString(3, 255, 'Nome'),
      codigo: optionalString(50),
      tipologia: z.enum([
        'residencial_horizontal',
        'residencial_vertical',
        'comercial',
        'retrofit',
        'misto'
      ]).optional(),
      cidade: optionalString(100),
      estado: z.string()
        .length(2, 'Estado deve ter 2 caracteres (UF)')
        .optional()
        .or(z.literal('')),
      responsavel_tecnico: optionalString(255),
    })

    export type ObraFormData = z.infer<typeof obraFormSchema>

    // Keep old export for backwards compatibility with ObraForm example
    export const obraSchema = obraFormSchema
    ```

    This preserves backwards compatibility with the existing ObraForm example component while providing the correct schema for Phase 2.
  </action>
  <verify>
    - TypeScript compiles: `cd arden && npx tsc --noEmit`
    - Schema exports tipologiaOptions: `grep "tipologiaOptions" arden/lib/validations/obra.ts`
    - Schema has cidade/estado: `grep "cidade\|estado" arden/lib/validations/obra.ts`
  </verify>
  <done>
    obraFormSchema exports with fields matching database: nome (required), codigo, tipologia, cidade, estado, responsavel_tecnico (all optional).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create obras data access layer</name>
  <files>arden/lib/supabase/queries/obras.ts</files>
  <action>
    Create arden/lib/supabase/queries/obras.ts with typed CRUD functions:

    ```typescript
    import { createClient } from '@/lib/supabase/client'

    // Type definitions based on database schema
    // Note: Full Supabase types should be generated later with `supabase gen types`
    export interface Obra {
      id: string
      cliente_id: string
      nome: string
      codigo: string | null
      tipologia: 'residencial_horizontal' | 'residencial_vertical' | 'comercial' | 'retrofit' | 'misto' | null
      latitude: number | null
      longitude: number | null
      responsavel_tecnico: string | null
      ativo: boolean
      arquivada: boolean
      config: Record<string, unknown>
      created_at: string
      updated_at: string
    }

    export interface ObraInsert {
      nome: string
      codigo?: string | null
      tipologia?: Obra['tipologia']
      latitude?: number | null
      longitude?: number | null
      responsavel_tecnico?: string | null
    }

    export interface ObraUpdate {
      nome?: string
      codigo?: string | null
      tipologia?: Obra['tipologia']
      latitude?: number | null
      longitude?: number | null
      responsavel_tecnico?: string | null
      arquivada?: boolean
    }

    /**
     * Lista obras do cliente atual.
     * RLS filtra automaticamente por cliente_id.
     */
    export async function listObras(options?: { includeArchived?: boolean }): Promise<Obra[]> {
      const supabase = createClient()

      let query = supabase
        .from('obras')
        .select('*')
        .order('created_at', { ascending: false })

      if (!options?.includeArchived) {
        query = query.eq('arquivada', false)
      }

      const { data, error } = await query

      if (error) {
        throw new Error(`Erro ao listar obras: ${error.message}`)
      }

      return data || []
    }

    /**
     * Busca uma obra pelo ID.
     */
    export async function getObra(id: string): Promise<Obra> {
      const supabase = createClient()

      const { data, error } = await supabase
        .from('obras')
        .select('*')
        .eq('id', id)
        .single()

      if (error) {
        throw new Error(`Erro ao buscar obra: ${error.message}`)
      }

      return data
    }

    /**
     * Cria uma nova obra.
     * Requer permissao de admin (RLS).
     */
    export async function createObra(obra: ObraInsert): Promise<Obra> {
      const supabase = createClient()

      const { data, error } = await supabase
        .from('obras')
        .insert(obra)
        .select()
        .single()

      if (error) {
        if (error.code === '42501') {
          throw new Error('Voce nao tem permissao para criar obras')
        }
        throw new Error(`Erro ao criar obra: ${error.message}`)
      }

      return data
    }

    /**
     * Atualiza uma obra existente.
     * Requer permissao de admin (RLS).
     */
    export async function updateObra(id: string, updates: ObraUpdate): Promise<Obra> {
      const supabase = createClient()

      const { data, error } = await supabase
        .from('obras')
        .update(updates)
        .eq('id', id)
        .select()
        .single()

      if (error) {
        if (error.code === '42501') {
          throw new Error('Voce nao tem permissao para editar obras')
        }
        throw new Error(`Erro ao atualizar obra: ${error.message}`)
      }

      return data
    }

    /**
     * Arquiva uma obra (soft delete).
     */
    export async function archiveObra(id: string): Promise<Obra> {
      return updateObra(id, { arquivada: true })
    }

    /**
     * Restaura uma obra arquivada.
     */
    export async function restoreObra(id: string): Promise<Obra> {
      return updateObra(id, { arquivada: false })
    }
    ```

    Create the queries directory if it doesn't exist:
    ```bash
    mkdir -p arden/lib/supabase/queries
    ```
  </action>
  <verify>
    - File exists: `ls arden/lib/supabase/queries/obras.ts`
    - TypeScript compiles: `cd arden && npx tsc --noEmit`
    - Exports all functions: `grep "export async function" arden/lib/supabase/queries/obras.ts | wc -l` should be 6
  </verify>
  <done>
    Data access layer exists with listObras, getObra, createObra, updateObra, archiveObra, restoreObra functions, all typed and with Portuguese error messages.
  </done>
</task>

</tasks>

<verification>
- [ ] All 5 shadcn components exist in arden/components/ui/
- [ ] Toaster is rendered in root layout
- [ ] obraFormSchema has tipologia enum and cidade/estado fields
- [ ] obras.ts exports 6 async functions (list, get, create, update, archive, restore)
- [ ] Build passes without errors: `cd arden && npm run build`
</verification>

<success_criteria>
1. `npm run build` succeeds with all new components
2. Toast notifications work (Toaster in layout)
3. Obra form schema validates tipologia as enum, estado as 2-char string
4. Data access functions are importable and type-safe
</success_criteria>

<output>
After completion, create `.planning/phases/02-obras/02-01-SUMMARY.md`
</output>
