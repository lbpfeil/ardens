---
phase: 02-obras
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - arden/app/app/obras/_components/obra-form-modal.tsx
  - arden/app/app/obras/_components/obras-table.tsx
  - arden/app/app/obras/_components/archive-confirmation.tsx
  - arden/app/app/obras/page.tsx
autonomous: true

must_haves:
  truths:
    - "Usuario pode editar dados de uma obra existente"
    - "Usuario pode arquivar uma obra (soft delete)"
    - "Obra arquivada desaparece da lista quando filtro e 'Ativas'"
    - "Usuario pode restaurar obra arquivada"
  artifacts:
    - path: "arden/app/app/obras/_components/archive-confirmation.tsx"
      provides: "AlertDialog for archive confirmation"
      min_lines: 40
    - path: "arden/app/app/obras/_components/obra-form-modal.tsx"
      provides: "Modal supporting both create and edit modes"
      contains: "mode"
  key_links:
    - from: "arden/app/app/obras/_components/obras-table.tsx"
      to: "ObraFormModal (edit mode)"
      via: "dropdown Editar action"
      pattern: "setEditingObra"
    - from: "arden/app/app/obras/_components/obras-table.tsx"
      to: "ArchiveConfirmation"
      via: "dropdown Arquivar action"
      pattern: "setArchivingObra"
    - from: "arden/app/app/obras/_components/archive-confirmation.tsx"
      to: "archiveObra/restoreObra mutation"
      via: "onConfirm handler"
      pattern: "archiveObra|restoreObra"
---

<objective>
Add edit and archive functionality to obras management. Users can modify existing obras via modal and archive/restore obras with confirmation.

Purpose: Complete CRUD cycle - edit updates persisted data, archive provides soft-delete with recovery option.
Output: Edit modal pre-filled with obra data, archive/restore flow with confirmation dialog.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-obras/02-RESEARCH.md
@.planning/phases/02-obras/02-CONTEXT.md
@.planning/phases/02-obras/02-02-SUMMARY.md
@arden/app/app/obras/_components/obra-form-modal.tsx
@arden/app/app/obras/_components/obras-table.tsx
@arden/lib/supabase/queries/obras.ts
@arden/components/ui/alert-dialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend modal for edit mode</name>
  <files>
    arden/app/app/obras/_components/obra-form-modal.tsx
    arden/app/app/obras/_components/obras-table.tsx
    arden/app/app/obras/page.tsx
  </files>
  <action>
    **1. Update arden/app/app/obras/_components/obra-form-modal.tsx:**

    Extend to support edit mode:
    - Add props: `mode: 'create' | 'edit'`, `obra?: Obra` (the obra being edited)
    - When mode='edit' and obra provided:
      - Dialog title: "Editar Obra" (instead of "Nova Obra")
      - Pre-fill defaultValues from obra data
      - Submit button text: "Salvar" (instead of "Criar Obra")
      - On submit: call updateObra(obra.id, data) instead of createObra
      - Success toast: "Obra atualizada com sucesso"
    - Reset form when obra prop changes (useEffect with obra.id dependency)
    - Handle form reset properly when switching between create/edit

    Key change for defaultValues:
    ```typescript
    const defaultValues = useMemo(() => ({
      nome: obra?.nome ?? '',
      codigo: obra?.codigo ?? '',
      tipologia: obra?.tipologia ?? undefined,
      cidade: '', // Not in DB, keep empty
      estado: '', // Not in DB, keep empty
      responsavel_tecnico: obra?.responsavel_tecnico ?? '',
    }), [obra])

    const form = useForm<ObraFormData>({
      resolver: zodResolver(obraFormSchema),
      defaultValues,
    })

    useEffect(() => {
      form.reset(defaultValues)
    }, [obra?.id])
    ```

    **2. Update obras-table.tsx:**
    - Add prop: `onEditClick: (obra: Obra) => void`
    - Enable "Editar" dropdown item
    - onClick: call onEditClick(obra) with the row's obra

    **3. Update page.tsx client wrapper:**
    - Add state: `editingObra: Obra | null`
    - When "Editar" clicked: setEditingObra(obra), open modal
    - Pass mode='edit' and obra={editingObra} to modal when editing
    - On modal close/success: setEditingObra(null)
    - On success: router.refresh() to reload data
  </action>
  <verify>
    - Click "Editar" in dropdown: modal opens with obra data pre-filled
    - Title shows "Editar Obra"
    - Change nome, click "Salvar": toast shows "Obra atualizada com sucesso"
    - Table shows updated nome after refresh
  </verify>
  <done>
    Edit flow complete: dropdown "Editar" opens modal with pre-filled data, submit updates obra and refreshes list.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add archive/restore with confirmation</name>
  <files>
    arden/app/app/obras/_components/archive-confirmation.tsx
    arden/app/app/obras/_components/obras-table.tsx
    arden/app/app/obras/page.tsx
  </files>
  <action>
    **1. Create arden/app/app/obras/_components/archive-confirmation.tsx:**

    AlertDialog component for archive confirmation:
    ```typescript
    'use client'

    import { useState } from 'react'
    import {
      AlertDialog,
      AlertDialogAction,
      AlertDialogCancel,
      AlertDialogContent,
      AlertDialogDescription,
      AlertDialogFooter,
      AlertDialogHeader,
      AlertDialogTitle,
    } from '@/components/ui/alert-dialog'
    import { archiveObra, restoreObra } from '@/lib/supabase/queries/obras'
    import { toast } from 'sonner'

    interface ArchiveConfirmationProps {
      open: boolean
      onOpenChange: (open: boolean) => void
      obra: { id: string; nome: string; arquivada: boolean } | null
      onSuccess: () => void
    }

    export function ArchiveConfirmation({
      open,
      onOpenChange,
      obra,
      onSuccess,
    }: ArchiveConfirmationProps) {
      const [isLoading, setIsLoading] = useState(false)
      const isArchived = obra?.arquivada ?? false

      const handleConfirm = async () => {
        if (!obra) return

        setIsLoading(true)
        try {
          if (isArchived) {
            await restoreObra(obra.id)
            toast.success('Obra restaurada com sucesso')
          } else {
            await archiveObra(obra.id)
            toast.success('Obra arquivada com sucesso')
          }
          onSuccess()
          onOpenChange(false)
        } catch (error) {
          toast.error(error instanceof Error ? error.message : 'Erro ao processar')
        } finally {
          setIsLoading(false)
        }
      }

      return (
        <AlertDialog open={open} onOpenChange={onOpenChange}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>
                {isArchived ? 'Restaurar obra?' : 'Arquivar obra?'}
              </AlertDialogTitle>
              <AlertDialogDescription>
                {isArchived
                  ? `Tem certeza que deseja restaurar a obra "${obra?.nome}"? Ela voltara a aparecer na lista de obras ativas.`
                  : `Tem certeza que deseja arquivar a obra "${obra?.nome}"? A obra sera removida da lista principal, mas podera ser restaurada posteriormente.`
                }
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel disabled={isLoading}>Cancelar</AlertDialogCancel>
              <AlertDialogAction
                onClick={handleConfirm}
                disabled={isLoading}
                className={!isArchived ? 'bg-destructive text-destructive-foreground hover:bg-destructive/90' : ''}
              >
                {isLoading
                  ? (isArchived ? 'Restaurando...' : 'Arquivando...')
                  : (isArchived ? 'Restaurar' : 'Arquivar')
                }
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      )
    }
    ```

    **2. Update obras-table.tsx:**
    - Add prop: `onArchiveClick: (obra: Obra) => void`
    - Update dropdown to show correct action based on obra.arquivada:
      - If not archived: show "Arquivar" (destructive style)
      - If archived: show "Restaurar"
    - onClick: call onArchiveClick(obra)

    **3. Update page.tsx client wrapper:**
    - Add state: `archivingObra: Obra | null`
    - Import and render ArchiveConfirmation component
    - Pass archivingObra to ArchiveConfirmation
    - On success: router.refresh()
  </action>
  <verify>
    - Click "Arquivar" in dropdown: AlertDialog opens with obra name
    - Click "Arquivar" button: toast shows "Obra arquivada com sucesso"
    - Table refreshes, obra disappears (if filter is "Ativas")
    - Switch filter to "Arquivadas": archived obra appears
    - Click "Restaurar": AlertDialog shows restore message
    - Confirm restore: obra appears in "Ativas" list again
  </verify>
  <done>
    Archive/restore flow complete: confirmation dialog, soft delete works, obra can be restored from Arquivadas filter.
  </done>
</task>

</tasks>

<verification>
- [ ] "Editar" in dropdown opens modal with obra data
- [ ] Edit modal title is "Editar Obra"
- [ ] Edit submit calls updateObra and shows success toast
- [ ] "Arquivar" in dropdown opens AlertDialog
- [ ] Archive confirmation shows obra name
- [ ] Archive success removes obra from Ativas view
- [ ] Archived obra visible in Arquivadas filter
- [ ] "Restaurar" action appears for archived obras
- [ ] Restore confirmation works and moves obra back to Ativas
</verification>

<success_criteria>
1. User clicks "Editar" on obra row, modal opens with pre-filled data
2. User changes nome, clicks "Salvar", sees "Obra atualizada com sucesso", modal closes, table shows new nome
3. User clicks "Arquivar", sees confirmation dialog with obra name
4. User confirms, sees "Obra arquivada com sucesso", obra disappears from list
5. User switches filter to "Arquivadas", sees archived obra with "Restaurar" option
6. User clicks "Restaurar", confirms, obra returns to Ativas list
</success_criteria>

<output>
After completion, create `.planning/phases/02-obras/02-03-SUMMARY.md`
</output>
