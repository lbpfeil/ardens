# Phase 5.1: Revisoes de Servicos - Research

**Researched:** 2026-01-22
**Domain:** Revision control for FVS services, version tracking per obra
**Confidence:** HIGH

## Summary

Phase 5.1 implements a revision control system for FVS services (servicos), following PBQP-H standards where revisions are tracked as "Rev. 00", "Rev. 01", "Rev. 02", etc. The key insight is that obras use a SNAPSHOT of the service at the revision they activated, and must explicitly update to newer revisions.

The implementation requires schema additions to track revisions on `servicos`, a new `servico_revisoes` table for history, and an update to `obra_servicos` to track which revision each obra is using. The UI changes affect the service edit modal (requiring change description), the service detail page (showing revision history), and the obra servicos page (showing revision status and update option).

**Primary recommendation:** Use a separate `servico_revisoes` table for history (not JSON column) to enable proper querying, ordering, and future diff functionality. The revision number should be stored as a padded string ("00", "01", etc.) for PBQP-H compliance and display consistency.

## Standard Stack

The revision feature uses no new libraries - it extends existing patterns with schema changes and UI additions.

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Supabase | existing | Database + RLS | Already in use, supports all revision queries |
| React Hook Form | existing | Edit modal with description field | Already in use for servico forms |
| Zod | existing | Validation for description field | Already in use for form validation |

### No New Dependencies

This feature is implemented entirely with existing stack. Key considerations:
- Revision history is simple append-only (no complex versioning library needed)
- Diff functionality (REV-06) can be deferred or done with simple string comparison
- No need for event sourcing or temporal tables

## Architecture Patterns

### Recommended Schema Changes

```sql
-- 1. Add revision columns to servicos
ALTER TABLE servicos ADD COLUMN revisao VARCHAR(5) NOT NULL DEFAULT '00';
ALTER TABLE servicos ADD COLUMN revisao_descricao TEXT;
ALTER TABLE servicos ADD COLUMN revisao_updated_at TIMESTAMPTZ;
ALTER TABLE servicos ADD COLUMN revisao_updated_by UUID REFERENCES auth.users(id);

-- 2. Create revision history table
CREATE TABLE servico_revisoes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  servico_id UUID NOT NULL REFERENCES servicos(id) ON DELETE CASCADE,
  revisao VARCHAR(5) NOT NULL,
  descricao TEXT NOT NULL,
  -- Snapshot of servico fields at this revision (for future diff)
  snapshot_codigo VARCHAR(50) NOT NULL,
  snapshot_nome VARCHAR(255) NOT NULL,
  snapshot_categoria categoria_servico,
  snapshot_referencia_normativa TEXT,
  -- Audit
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id),

  -- Each servico+revision combination is unique
  UNIQUE(servico_id, revisao)
);

CREATE INDEX idx_servico_revisoes_servico ON servico_revisoes(servico_id);
CREATE INDEX idx_servico_revisoes_created ON servico_revisoes(servico_id, created_at DESC);

-- Enable RLS
ALTER TABLE servico_revisoes ENABLE ROW LEVEL SECURITY;

-- 3. Add revision tracking to obra_servicos
ALTER TABLE obra_servicos ADD COLUMN revisao_ativa VARCHAR(5) NOT NULL DEFAULT '00';
```

### Pattern 1: Revision Increment on Edit

**What:** When editing a servico, automatically increment revision and record history
**When to use:** Every time updateServico is called with content changes
**Example:**

```typescript
// lib/supabase/queries/servicos.ts

export interface ServicoUpdateWithRevision extends ServicoUpdate {
  descricao_mudanca: string  // Required for revision increment
}

export async function updateServicoWithRevision(
  id: string,
  updates: ServicoUpdateWithRevision
): Promise<Servico> {
  const supabase = createClient()

  // 1. Get current servico
  const { data: current, error: fetchError } = await supabase
    .from('servicos')
    .select('*')
    .eq('id', id)
    .single()

  if (fetchError) throw new Error(`Erro ao buscar servico: ${fetchError.message}`)

  // 2. Calculate next revision
  const currentRev = parseInt(current.revisao, 10)
  const nextRev = String(currentRev + 1).padStart(2, '0')

  // 3. Create revision history record (snapshot current state before update)
  const { error: historyError } = await supabase
    .from('servico_revisoes')
    .insert({
      servico_id: id,
      revisao: nextRev,
      descricao: updates.descricao_mudanca,
      snapshot_codigo: updates.codigo ?? current.codigo,
      snapshot_nome: updates.nome ?? current.nome,
      snapshot_categoria: updates.categoria ?? current.categoria,
      snapshot_referencia_normativa: updates.referencia_normativa ?? current.referencia_normativa,
      // created_by: userId, // TODO: get from auth session
    })

  if (historyError) throw new Error(`Erro ao registrar revisao: ${historyError.message}`)

  // 4. Update servico with new revision
  const { codigo, nome, categoria, referencia_normativa } = updates
  const { data, error: updateError } = await supabase
    .from('servicos')
    .update({
      codigo,
      nome,
      categoria,
      referencia_normativa,
      revisao: nextRev,
      revisao_descricao: updates.descricao_mudanca,
      revisao_updated_at: new Date().toISOString(),
      // revisao_updated_by: userId, // TODO: get from auth session
    })
    .eq('id', id)
    .select()
    .single()

  if (updateError) throw new Error(`Erro ao atualizar servico: ${updateError.message}`)

  return data
}
```

### Pattern 2: Activate Service with Current Revision

**What:** When activating a service for an obra, capture the current revision
**When to use:** In activateServico function
**Example:**

```typescript
// lib/supabase/queries/obra-servicos.ts

export async function activateServicoWithRevision(
  obraId: string,
  servicoId: string
): Promise<ObraServico> {
  const supabase = createClient()

  // Get current revision of the servico
  const { data: servico, error: servicoError } = await supabase
    .from('servicos')
    .select('revisao')
    .eq('id', servicoId)
    .single()

  if (servicoError) throw new Error(`Erro ao buscar servico: ${servicoError.message}`)

  // Upsert with current revision
  const { data, error } = await supabase
    .from('obra_servicos')
    .upsert(
      {
        obra_id: obraId,
        servico_id: servicoId,
        ativo: true,
        revisao_ativa: servico.revisao,
      },
      { onConflict: 'obra_id,servico_id' }
    )
    .select()
    .single()

  if (error) throw new Error(`Erro ao ativar servico: ${error.message}`)

  return data
}
```

### Pattern 3: Detect Outdated Revision

**What:** Compare obra's active revision with servico's current revision
**When to use:** In listServicosForObra query and UI components
**Example:**

```typescript
// lib/supabase/queries/obra-servicos.ts

export interface ServicoWithRevisionStatus extends Servico {
  obra_servico_id: string | null
  ativo_na_obra: boolean
  revisao_ativa: string | null      // Revision this obra is using
  revisao_atual: string             // Current revision in biblioteca
  has_newer_revision: boolean       // True if biblioteca has newer
}

export async function listServicosForObraWithRevision(
  obraId: string
): Promise<ServicoWithRevisionStatus[]> {
  const supabase = createClient()

  // Get all non-archived servicos with their activation status for this obra
  const { data, error } = await supabase
    .from('servicos')
    .select(`
      *,
      obra_servicos!left(id, ativo, revisao_ativa)
    `)
    .eq('arquivado', false)
    .order('codigo', { ascending: true })

  if (error) throw new Error(`Erro ao listar servicos: ${error.message}`)

  return (data || []).map(servico => {
    const obraServico = servico.obra_servicos?.[0]
    const revisaoAtiva = obraServico?.revisao_ativa ?? null
    const hasNewer = revisaoAtiva !== null && revisaoAtiva < servico.revisao

    return {
      ...servico,
      obra_servico_id: obraServico?.id ?? null,
      ativo_na_obra: !!obraServico?.ativo,
      revisao_ativa: revisaoAtiva,
      revisao_atual: servico.revisao,
      has_newer_revision: hasNewer,
      obra_servicos: undefined,
    } as ServicoWithRevisionStatus
  })
}
```

### Pattern 4: Update Obra Revision

**What:** Allow user to update to latest revision
**When to use:** Button click on obra servicos page
**Example:**

```typescript
// lib/supabase/queries/obra-servicos.ts

export async function updateObraServicoRevision(
  obraId: string,
  servicoId: string
): Promise<ObraServico> {
  const supabase = createClient()

  // Get current servico revision
  const { data: servico, error: servicoError } = await supabase
    .from('servicos')
    .select('revisao')
    .eq('id', servicoId)
    .single()

  if (servicoError) throw new Error(`Erro ao buscar servico: ${servicoError.message}`)

  // Update obra_servicos to latest revision
  const { data, error } = await supabase
    .from('obra_servicos')
    .update({ revisao_ativa: servico.revisao })
    .eq('obra_id', obraId)
    .eq('servico_id', servicoId)
    .select()
    .single()

  if (error) throw new Error(`Erro ao atualizar revisao: ${error.message}`)

  return data
}
```

### Anti-Patterns to Avoid

- **Auto-update obra revision:** Never automatically update obra's revision when biblioteca updates - this breaks traceability for audits
- **JSON column for history:** Avoid storing revision history as JSON in servicos table - makes querying and reporting difficult
- **Floating point revision:** Never use decimal revisions (1.1, 1.2) - PBQP-H standard uses integer-based "00", "01" format
- **Deleting history:** Never delete revision history records - audit trail must be immutable

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Revision comparison | String comparison | Numeric comparison after parseInt | "09" < "10" works, but "9" > "10" as strings |
| Zero-padding | Manual string formatting | `String(n).padStart(2, '0')` | Consistent 2-digit format |
| History ordering | Manual sort | `ORDER BY created_at DESC` or `ORDER BY revisao DESC` | DB handles efficiently |
| Concurrent edit | Locking mechanism | Optimistic concurrency with updated_at | Already supported by Supabase |

**Key insight:** The revision system is fundamentally simple - append-only history with string comparison. Avoid over-engineering with event sourcing or complex versioning libraries.

## Common Pitfalls

### Pitfall 1: Edit Without Revision Increment

**What goes wrong:** User edits servico but revision stays the same
**Why it happens:** Using existing `updateServico` instead of `updateServicoWithRevision`
**How to avoid:**
- Remove/deprecate the plain `updateServico` function
- Make description field required in edit modal
- Validation: reject empty description
**Warning signs:** servicos.revisao stays at "00" after multiple edits

### Pitfall 2: Revision Mismatch After Activation

**What goes wrong:** Obra activates servico but revisao_ativa is null or "00"
**Why it happens:** Using old `activateServico` without revision capture
**How to avoid:**
- Update `activateServico` to always copy current revision
- Migration: backfill existing obra_servicos with current servico revision
**Warning signs:** All obras showing "Rev. 00" regardless of actual servico revision

### Pitfall 3: Revision Comparison Bug

**What goes wrong:** "Rev. 9" shown as newer than "Rev. 10"
**Why it happens:** String comparison: "9" > "10" alphabetically
**How to avoid:**
- Always use zero-padded format ("09" not "9")
- Compare with `parseInt(revA, 10) < parseInt(revB, 10)`
**Warning signs:** Incorrect "nova revisao disponivel" indicators

### Pitfall 4: Missing Initial Revision Record

**What goes wrong:** New servicos have no history entry for Rev. 00
**Why it happens:** Only recording history on UPDATE, not CREATE
**How to avoid:**
- Create initial revision record when servico is created
- Description: "Criacao do servico" or similar
**Warning signs:** Revision history empty for servicos created after feature launch

### Pitfall 5: RLS Policy Missing for servico_revisoes

**What goes wrong:** Users cannot see revision history
**Why it happens:** New table without RLS policy
**How to avoid:**
- Add SELECT policy matching servicos (same cliente_id check)
- Add INSERT policy for admin only
**Warning signs:** Empty revision history in UI, permission errors

## Code Examples

### Validation Schema for Edit Modal

```typescript
// lib/validations/servico.ts

export const servicoEditFormSchema = z.object({
  codigo: requiredString(1, 50, 'Codigo'),
  nome: requiredString(3, 255, 'Nome'),
  categoria: z.enum([
    'fundacao', 'estrutura', 'alvenaria', 'revestimento',
    'acabamento', 'instalacoes', 'cobertura', 'esquadrias',
    'pintura', 'impermeabilizacao', 'outros',
  ]).optional().nullable(),
  referencia_normativa: optionalString(500),
  // New required field for revision
  descricao_mudanca: requiredString(3, 500, 'Descricao da mudanca'),
})

export type ServicoEditFormData = z.infer<typeof servicoEditFormSchema>
```

### Revision Badge Component

```typescript
// components/ui/revision-badge.tsx

interface RevisionBadgeProps {
  revisao: string
  hasNewer?: boolean
}

export function RevisionBadge({ revisao, hasNewer }: RevisionBadgeProps) {
  return (
    <div className="flex items-center gap-1.5">
      <Badge variant="outline" className="font-mono text-xs">
        Rev. {revisao}
      </Badge>
      {hasNewer && (
        <Badge variant="warning" className="text-xs">
          Atualizar
        </Badge>
      )}
    </div>
  )
}
```

### Revision History Query

```typescript
// lib/supabase/queries/servico-revisoes.ts

export interface ServicoRevisao {
  id: string
  servico_id: string
  revisao: string
  descricao: string
  created_at: string
  created_by: string | null
}

export async function listServicoRevisoes(servicoId: string): Promise<ServicoRevisao[]> {
  const supabase = createClient()

  const { data, error } = await supabase
    .from('servico_revisoes')
    .select('*')
    .eq('servico_id', servicoId)
    .order('created_at', { ascending: false })

  if (error) throw new Error(`Erro ao listar revisoes: ${error.message}`)

  return data || []
}
```

### UI: Revision History Panel

```typescript
// Simplified pattern for revision history display on servico detail page

<Card className="bg-surface-100 border-border">
  <CardHeader>
    <CardTitle className="text-sm font-medium">Historico de Revisoes</CardTitle>
  </CardHeader>
  <CardContent>
    {revisoes.length === 0 ? (
      <p className="text-sm text-foreground-muted">Nenhuma revisao registrada</p>
    ) : (
      <div className="space-y-3">
        {revisoes.map((rev) => (
          <div key={rev.id} className="flex items-start gap-3 border-b border-border pb-3 last:border-0">
            <Badge variant="outline" className="font-mono shrink-0">
              Rev. {rev.revisao}
            </Badge>
            <div className="min-w-0">
              <p className="text-sm text-foreground">{rev.descricao}</p>
              <p className="text-xs text-foreground-muted mt-1">
                {formatDate(rev.created_at)}
              </p>
            </div>
          </div>
        ))}
      </div>
    )}
  </CardContent>
</Card>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| No revision tracking | Revision field on servicos | This phase | Enables PBQP-H compliance |
| Implicit updates | Explicit revision increment | This phase | Audit trail for changes |
| Global service state | Obra-specific revision | This phase | Independent update cycles |

**PBQP-H Standard:**
- Revision format: "00", "01", "02"... (zero-padded integers)
- Every document change requires revision increment
- Changes must be documented (description required)
- Audit trail must be preserved

## Open Questions

1. **Migration strategy for existing servicos**
   - What we know: Existing servicos have no revision data
   - What's unclear: Should they start at "00" or "01"?
   - Recommendation: Start at "00" with description "Revisao inicial (migracao)"

2. **Snapshot depth for items**
   - What we know: Current design snapshots servico fields only
   - What's unclear: Should itens_servico also be snapshotted?
   - Recommendation: Defer item snapshotting to REV-06 (diff feature) - adds complexity

3. **Author tracking before auth**
   - What we know: created_by needs user ID from auth session
   - What's unclear: DEV_CLIENTE_ID pattern for users doesn't exist yet
   - Recommendation: Make created_by nullable initially, backfill when auth is complete

## Sources

### Primary (HIGH confidence)
- `database/schema.sql` - Current servicos and obra_servicos structure
- `arden/lib/supabase/queries/servicos.ts` - Existing CRUD pattern
- `arden/lib/supabase/queries/obra-servicos.ts` - Activation pattern
- `arden/app/app/biblioteca/_components/servico-form-modal.tsx` - Current edit modal
- `.planning/phases/05.1-revisoes-servico/REQUIREMENTS.md` - Feature requirements

### Secondary (MEDIUM confidence)
- PBQP-H documentation patterns from web search
- Document revision control best practices

### Codebase Patterns (HIGH confidence)
- Phase 5 Research: `.planning/phases/05-biblioteca-fvs/05-RESEARCH.md`
- Servico detail page: `arden/app/app/biblioteca/[id]/`
- Obra servicos page: `arden/app/app/obras/[id]/servicos/`

## Metadata

**Confidence breakdown:**
- Schema design: HIGH - Follows established patterns, clear requirements
- Query patterns: HIGH - Extension of existing servicos.ts patterns
- UI components: HIGH - Uses existing shadcn components
- Migration: MEDIUM - Existing data handling needs care
- Auth integration: LOW - Depends on auth implementation (use nullable for now)

**Research date:** 2026-01-22
**Valid until:** 2026-02-22 (stable feature scope)
