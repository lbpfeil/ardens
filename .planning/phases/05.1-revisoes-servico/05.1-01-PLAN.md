---
phase: 05.1-revisoes-servico
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - database/schema.sql
  - database/migrations/001_servico_revisoes.sql
  - arden/lib/supabase/queries/servicos.ts
  - arden/lib/supabase/queries/servico-revisoes.ts
  - arden/lib/supabase/queries/obra-servicos.ts
autonomous: true

must_haves:
  truths:
    - "servicos table has revisao, revisao_descricao, revisao_updated_at columns"
    - "servico_revisoes table exists with history records"
    - "obra_servicos table has revisao_ativa column"
    - "Query functions for revision operations are callable"
  artifacts:
    - path: "database/migrations/001_servico_revisoes.sql"
      provides: "SQL migration for revision schema changes"
      contains: "ALTER TABLE servicos ADD COLUMN revisao"
    - path: "arden/lib/supabase/queries/servico-revisoes.ts"
      provides: "Revision history CRUD operations"
      exports: ["ServicoRevisao", "listServicoRevisoes", "createServicoRevisao"]
    - path: "arden/lib/supabase/queries/servicos.ts"
      provides: "Updated servico types with revision fields"
      exports: ["Servico", "updateServicoWithRevision"]
    - path: "arden/lib/supabase/queries/obra-servicos.ts"
      provides: "Updated activation with revision tracking"
      exports: ["ServicoWithRevisionStatus", "updateObraServicoRevision"]
  key_links:
    - from: "servico-revisoes.ts"
      to: "supabase.from('servico_revisoes')"
      via: "createClient"
      pattern: "from\\('servico_revisoes'\\)"
    - from: "servicos.ts"
      to: "servico_revisoes"
      via: "updateServicoWithRevision creates history"
      pattern: "createServicoRevisao|from\\('servico_revisoes'\\)"
---

<objective>
Setup schema changes and data access layer for revision control system

Purpose: Add revision tracking columns to servicos and obra_servicos tables, create servico_revisoes history table, and implement query functions for revision operations. This establishes the foundation for the revision UI in subsequent plans.

Output:
- SQL migration file for schema changes
- Updated servicos.ts with revision-aware types and functions
- New servico-revisoes.ts for history operations
- Updated obra-servicos.ts with revision tracking
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05.1-revisoes-servico/05.1-RESEARCH.md

# Existing code to modify
@arden/lib/supabase/queries/servicos.ts
@arden/lib/supabase/queries/obra-servicos.ts
@database/schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQL migration for revision schema</name>
  <files>database/migrations/001_servico_revisoes.sql, database/schema.sql</files>
  <action>
Create migration file database/migrations/001_servico_revisoes.sql (create migrations folder if needed):

```sql
-- Migration: Add revision tracking to servicos
-- Created: 2026-01-22

-- 1. Add revision columns to servicos
ALTER TABLE servicos ADD COLUMN IF NOT EXISTS revisao VARCHAR(5) NOT NULL DEFAULT '00';
ALTER TABLE servicos ADD COLUMN IF NOT EXISTS revisao_descricao TEXT;
ALTER TABLE servicos ADD COLUMN IF NOT EXISTS revisao_updated_at TIMESTAMPTZ;
ALTER TABLE servicos ADD COLUMN IF NOT EXISTS revisao_updated_by UUID REFERENCES auth.users(id);

-- 2. Create revision history table
CREATE TABLE IF NOT EXISTS servico_revisoes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  servico_id UUID NOT NULL REFERENCES servicos(id) ON DELETE CASCADE,
  revisao VARCHAR(5) NOT NULL,
  descricao TEXT NOT NULL,
  -- Snapshot of servico fields at this revision
  snapshot_codigo VARCHAR(50) NOT NULL,
  snapshot_nome VARCHAR(255) NOT NULL,
  snapshot_categoria categoria_servico,
  snapshot_referencia_normativa TEXT,
  -- Audit
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id),

  -- Each servico+revision combination is unique
  UNIQUE(servico_id, revisao)
);

-- Indexes for servico_revisoes
CREATE INDEX IF NOT EXISTS idx_servico_revisoes_servico ON servico_revisoes(servico_id);
CREATE INDEX IF NOT EXISTS idx_servico_revisoes_created ON servico_revisoes(servico_id, created_at DESC);

-- Enable RLS on servico_revisoes
ALTER TABLE servico_revisoes ENABLE ROW LEVEL SECURITY;

-- 3. Add revision tracking to obra_servicos
ALTER TABLE obra_servicos ADD COLUMN IF NOT EXISTS revisao_ativa VARCHAR(5) NOT NULL DEFAULT '00';

-- 4. RLS policies for servico_revisoes (read-only for all authenticated users of cliente)
CREATE POLICY "servico_revisoes_select" ON servico_revisoes
  FOR SELECT
  USING (
    servico_id IN (
      SELECT id FROM servicos WHERE cliente_id IN (
        SELECT cliente_id FROM usuario_clientes
        WHERE usuario_id = auth.uid() AND ativo = true
      )
    )
  );

-- Admin can insert revision history
CREATE POLICY "servico_revisoes_insert" ON servico_revisoes
  FOR INSERT
  WITH CHECK (
    servico_id IN (
      SELECT id FROM servicos WHERE cliente_id IN (
        SELECT cliente_id FROM usuario_clientes
        WHERE usuario_id = auth.uid() AND ativo = true
      )
    )
  );

-- 5. Backfill existing servicos with initial revision entry
INSERT INTO servico_revisoes (servico_id, revisao, descricao, snapshot_codigo, snapshot_nome, snapshot_categoria, snapshot_referencia_normativa)
SELECT
  id as servico_id,
  '00' as revisao,
  'Revisao inicial (migracao)' as descricao,
  codigo as snapshot_codigo,
  nome as snapshot_nome,
  categoria as snapshot_categoria,
  referencia_normativa as snapshot_referencia_normativa
FROM servicos
WHERE NOT EXISTS (
  SELECT 1 FROM servico_revisoes sr WHERE sr.servico_id = servicos.id
);

-- 6. Backfill existing obra_servicos with current servico revision
UPDATE obra_servicos os
SET revisao_ativa = COALESCE(
  (SELECT s.revisao FROM servicos s WHERE s.id = os.servico_id),
  '00'
)
WHERE os.revisao_ativa = '00' OR os.revisao_ativa IS NULL;
```

Also update database/schema.sql to include the new columns and table in the main schema definition (add them to the existing CREATE TABLE statements or as ALTERs after the main definitions).
  </action>
  <verify>File created at database/migrations/001_servico_revisoes.sql with all schema changes</verify>
  <done>Migration file exists with revision columns, history table, and RLS policies</done>
</task>

<task type="auto">
  <name>Task 2: Create servico-revisoes data access layer</name>
  <files>arden/lib/supabase/queries/servico-revisoes.ts</files>
  <action>
Create new file arden/lib/supabase/queries/servico-revisoes.ts:

```typescript
import { createClient } from '@/lib/supabase/client'
import type { CategoriaServico } from './servicos'

export interface ServicoRevisao {
  id: string
  servico_id: string
  revisao: string
  descricao: string
  snapshot_codigo: string
  snapshot_nome: string
  snapshot_categoria: CategoriaServico | null
  snapshot_referencia_normativa: string | null
  created_at: string
  created_by: string | null
}

export interface ServicoRevisaoInsert {
  servico_id: string
  revisao: string
  descricao: string
  snapshot_codigo: string
  snapshot_nome: string
  snapshot_categoria?: CategoriaServico | null
  snapshot_referencia_normativa?: string | null
}

/**
 * Lista historico de revisoes de um servico.
 * Ordenado do mais recente para o mais antigo.
 */
export async function listServicoRevisoes(servicoId: string): Promise<ServicoRevisao[]> {
  const supabase = createClient()

  const { data, error } = await supabase
    .from('servico_revisoes')
    .select('*')
    .eq('servico_id', servicoId)
    .order('created_at', { ascending: false })

  if (error) {
    throw new Error(`Erro ao listar revisoes: ${error.message}`)
  }

  return data || []
}

/**
 * Cria registro de revisao no historico.
 * Chamado internamente por updateServicoWithRevision.
 */
export async function createServicoRevisao(
  data: ServicoRevisaoInsert
): Promise<ServicoRevisao> {
  const supabase = createClient()

  const { data: revisao, error } = await supabase
    .from('servico_revisoes')
    .insert(data)
    .select()
    .single()

  if (error) {
    throw new Error(`Erro ao criar revisao: ${error.message}`)
  }

  return revisao
}

/**
 * Busca ultima revisao de um servico.
 */
export async function getLatestServicoRevisao(
  servicoId: string
): Promise<ServicoRevisao | null> {
  const supabase = createClient()

  const { data, error } = await supabase
    .from('servico_revisoes')
    .select('*')
    .eq('servico_id', servicoId)
    .order('created_at', { ascending: false })
    .limit(1)
    .single()

  if (error && error.code !== 'PGRST116') {
    // PGRST116 = no rows returned
    throw new Error(`Erro ao buscar revisao: ${error.message}`)
  }

  return data || null
}
```
  </action>
  <verify>File exists and exports ServicoRevisao, listServicoRevisoes, createServicoRevisao, getLatestServicoRevisao</verify>
  <done>servico-revisoes.ts provides revision history operations</done>
</task>

<task type="auto">
  <name>Task 3: Update servicos and obra-servicos with revision support</name>
  <files>arden/lib/supabase/queries/servicos.ts, arden/lib/supabase/queries/obra-servicos.ts</files>
  <action>
**Update servicos.ts:**

1. Add revision fields to Servico interface:
```typescript
export interface Servico {
  id: string
  cliente_id: string
  codigo: string
  nome: string
  categoria: CategoriaServico | null
  referencia_normativa: string | null
  ativo: boolean
  arquivado: boolean
  // Revision fields
  revisao: string
  revisao_descricao: string | null
  revisao_updated_at: string | null
  revisao_updated_by: string | null
  created_at: string
  updated_at: string
}
```

2. Add new interface for edit with revision:
```typescript
export interface ServicoUpdateWithRevision extends ServicoUpdate {
  descricao_mudanca: string  // Required for revision increment
}
```

3. Add updateServicoWithRevision function:
```typescript
/**
 * Atualiza servico e incrementa revisao.
 * Requer descricao da mudanca para rastreabilidade.
 */
export async function updateServicoWithRevision(
  id: string,
  updates: ServicoUpdateWithRevision
): Promise<Servico> {
  const supabase = createClient()

  // 1. Get current servico
  const { data: current, error: fetchError } = await supabase
    .from('servicos')
    .select('*')
    .eq('id', id)
    .single()

  if (fetchError) throw new Error(`Erro ao buscar servico: ${fetchError.message}`)

  // 2. Calculate next revision (current + 1, zero-padded)
  const currentRev = parseInt(current.revisao || '00', 10)
  const nextRev = String(currentRev + 1).padStart(2, '0')

  // 3. Prepare update data (excluding descricao_mudanca)
  const { descricao_mudanca, ...updateFields } = updates
  const finalData = {
    ...updateFields,
    revisao: nextRev,
    revisao_descricao: descricao_mudanca,
    revisao_updated_at: new Date().toISOString(),
  }

  // 4. Create revision history record
  const { error: historyError } = await supabase
    .from('servico_revisoes')
    .insert({
      servico_id: id,
      revisao: nextRev,
      descricao: descricao_mudanca,
      snapshot_codigo: updateFields.codigo ?? current.codigo,
      snapshot_nome: updateFields.nome ?? current.nome,
      snapshot_categoria: updateFields.categoria ?? current.categoria,
      snapshot_referencia_normativa: updateFields.referencia_normativa ?? current.referencia_normativa,
    })

  if (historyError) throw new Error(`Erro ao registrar revisao: ${historyError.message}`)

  // 5. Update servico with new revision
  const { data, error: updateError } = await supabase
    .from('servicos')
    .update(finalData)
    .eq('id', id)
    .select()
    .single()

  if (updateError) {
    if (updateError.code === '23505') {
      throw new Error('Ja existe um servico com este codigo')
    }
    throw new Error(`Erro ao atualizar servico: ${updateError.message}`)
  }

  return data
}
```

4. Update createServico to create initial revision:
```typescript
export async function createServico(servico: ServicoInsert): Promise<Servico> {
  const supabase = createClient()

  const { data, error } = await supabase
    .from('servicos')
    .insert({
      ...servico,
      cliente_id: DEV_CLIENTE_ID,
      revisao: '00',
    })
    .select()
    .single()

  if (error) {
    if (error.code === '23505') {
      throw new Error('Ja existe um servico com este codigo')
    }
    if (error.code === '42501') {
      throw new Error('Voce nao tem permissao para criar servicos')
    }
    throw new Error(`Erro ao criar servico: ${error.message}`)
  }

  // Create initial revision record
  await supabase
    .from('servico_revisoes')
    .insert({
      servico_id: data.id,
      revisao: '00',
      descricao: 'Criacao do servico',
      snapshot_codigo: data.codigo,
      snapshot_nome: data.nome,
      snapshot_categoria: data.categoria,
      snapshot_referencia_normativa: data.referencia_normativa,
    })

  return data
}
```

**Update obra-servicos.ts:**

1. Update ObraServico interface:
```typescript
export interface ObraServico {
  id: string
  obra_id: string
  servico_id: string
  ativo: boolean
  revisao_ativa: string
  created_at: string
}
```

2. Add ServicoWithRevisionStatus interface:
```typescript
export interface ServicoWithRevisionStatus extends Servico {
  obra_servico_id: string | null
  ativo_na_obra: boolean
  revisao_ativa: string | null      // Revision this obra is using
  revisao_atual: string             // Current revision in biblioteca
  has_newer_revision: boolean       // True if biblioteca has newer
}
```

3. Update activateServico to capture current revision:
```typescript
export async function activateServico(obraId: string, servicoId: string): Promise<ObraServico> {
  const supabase = createClient()

  // Get current revision of the servico
  const { data: servico, error: servicoError } = await supabase
    .from('servicos')
    .select('revisao')
    .eq('id', servicoId)
    .single()

  if (servicoError) throw new Error(`Erro ao buscar servico: ${servicoError.message}`)

  // Upsert: insert if not exists, update ativo=true if exists
  const { data, error } = await supabase
    .from('obra_servicos')
    .upsert(
      {
        obra_id: obraId,
        servico_id: servicoId,
        ativo: true,
        revisao_ativa: servico.revisao,
      },
      {
        onConflict: 'obra_id,servico_id',
      }
    )
    .select()
    .single()

  if (error) {
    if (error.code === '42501') {
      throw new Error('Voce nao tem permissao para ativar servicos na obra')
    }
    throw new Error(`Erro ao ativar servico: ${error.message}`)
  }

  return data
}
```

4. Add updateObraServicoRevision function:
```typescript
/**
 * Atualiza revisao de um servico na obra para a versao mais recente.
 */
export async function updateObraServicoRevision(
  obraId: string,
  servicoId: string
): Promise<ObraServico> {
  const supabase = createClient()

  // Get current servico revision
  const { data: servico, error: servicoError } = await supabase
    .from('servicos')
    .select('revisao')
    .eq('id', servicoId)
    .single()

  if (servicoError) throw new Error(`Erro ao buscar servico: ${servicoError.message}`)

  // Update obra_servicos to latest revision
  const { data, error } = await supabase
    .from('obra_servicos')
    .update({ revisao_ativa: servico.revisao })
    .eq('obra_id', obraId)
    .eq('servico_id', servicoId)
    .select()
    .single()

  if (error) throw new Error(`Erro ao atualizar revisao: ${error.message}`)

  return data
}
```

5. Add listServicosForObraWithRevision function:
```typescript
/**
 * Lista servicos para obra com status de revisao.
 * Inclui indicador se ha revisao mais nova disponivel.
 */
export async function listServicosForObraWithRevision(
  obraId: string
): Promise<ServicoWithRevisionStatus[]> {
  const supabase = createClient()

  // Get all non-archived servicos
  const { data: servicos, error: servicosError } = await supabase
    .from('servicos')
    .select('*')
    .eq('arquivado', false)
    .order('categoria', { ascending: true })
    .order('nome', { ascending: true })

  if (servicosError) throw new Error(`Erro ao listar servicos: ${servicosError.message}`)

  // Get obra_servicos for this obra
  const { data: obraServicos, error: obraServicosError } = await supabase
    .from('obra_servicos')
    .select('id, servico_id, ativo, revisao_ativa')
    .eq('obra_id', obraId)

  if (obraServicosError) throw new Error(`Erro ao listar obra_servicos: ${obraServicosError.message}`)

  // Build map for quick lookup
  const obraServicoMap = new Map(
    (obraServicos || []).map(os => [os.servico_id, os])
  )

  // Merge with revision status
  return (servicos || []).map(servico => {
    const obraServico = obraServicoMap.get(servico.id)
    const revisaoAtiva = obraServico?.revisao_ativa ?? null
    const revisaoAtual = servico.revisao || '00'
    const hasNewer = revisaoAtiva !== null &&
      parseInt(revisaoAtiva, 10) < parseInt(revisaoAtual, 10)

    return {
      ...servico,
      obra_servico_id: obraServico?.id ?? null,
      ativo_na_obra: !!obraServico?.ativo,
      revisao_ativa: revisaoAtiva,
      revisao_atual: revisaoAtual,
      has_newer_revision: hasNewer,
    } as ServicoWithRevisionStatus
  })
}
```

6. Update bulkActivateServicos to capture revisions:
```typescript
export async function bulkActivateServicos(
  obraId: string,
  servicoIds: string[]
): Promise<ObraServico[]> {
  if (servicoIds.length === 0) return []

  const supabase = createClient()

  // Get current revisions for all servicos
  const { data: servicos, error: servicosError } = await supabase
    .from('servicos')
    .select('id, revisao')
    .in('id', servicoIds)

  if (servicosError) throw new Error(`Erro ao buscar servicos: ${servicosError.message}`)

  // Build revision map
  const revisionMap = new Map((servicos || []).map(s => [s.id, s.revisao]))

  const records = servicoIds.map(servicoId => ({
    obra_id: obraId,
    servico_id: servicoId,
    ativo: true,
    revisao_ativa: revisionMap.get(servicoId) || '00',
  }))

  const { data, error } = await supabase
    .from('obra_servicos')
    .upsert(records, {
      onConflict: 'obra_id,servico_id',
    })
    .select()

  if (error) {
    throw new Error(`Erro ao ativar servicos: ${error.message}`)
  }

  return data || []
}
```
  </action>
  <verify>
- `npm run build` succeeds
- servicos.ts exports Servico with revision fields, updateServicoWithRevision
- obra-servicos.ts exports ServicoWithRevisionStatus, updateObraServicoRevision, listServicosForObraWithRevision
  </verify>
  <done>Data access layer supports revision tracking for servicos and obra_servicos</done>
</task>

</tasks>

<verification>
1. database/migrations/001_servico_revisoes.sql exists with schema changes
2. arden/lib/supabase/queries/servico-revisoes.ts exists with history operations
3. arden/lib/supabase/queries/servicos.ts updated with revision fields and updateServicoWithRevision
4. arden/lib/supabase/queries/obra-servicos.ts updated with revision tracking
5. `npm run build` passes without TypeScript errors
</verification>

<success_criteria>
- Migration file defines servicos revision columns, servico_revisoes table, obra_servicos.revisao_ativa
- servico-revisoes.ts exports: ServicoRevisao, listServicoRevisoes, createServicoRevisao, getLatestServicoRevisao
- servicos.ts exports: Servico (with revision fields), ServicoUpdateWithRevision, updateServicoWithRevision
- obra-servicos.ts exports: ObraServico (with revisao_ativa), ServicoWithRevisionStatus, updateObraServicoRevision, listServicosForObraWithRevision
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-revisoes-servico/05.1-01-SUMMARY.md`
</output>
