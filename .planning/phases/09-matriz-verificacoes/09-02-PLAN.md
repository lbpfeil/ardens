---
phase: 09-matriz-verificacoes
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - arden/app/app/obras/[id]/verificacoes/page.tsx
  - arden/app/app/obras/[id]/verificacoes/_components/matriz-client.tsx
  - arden/app/app/obras/[id]/verificacoes/_components/matriz-grid.tsx
  - arden/app/app/obras/[id]/verificacoes/_components/matriz-header.tsx
autonomous: true

must_haves:
  truths:
    - "Page wrapper uses bg-background min-h-full pattern"
    - "Header (h1 + description) is in Server Component, not Client"
    - "Server-side query uses getMatrizData with obra ID from params"
    - "Matrix renders services as rows and units as columns in CSS Grid"
    - "Scroll horizontal keeps service column fixed at left"
    - "Scroll vertical keeps header rows fixed at top"
    - "Corner cell overlaps all other sticky elements during scroll"
    - "Agrupamento headers show group names spanning their unit columns"
    - "Unit name headers show below agrupamento headers"
    - "First agrupamento is expanded by default, others collapsed"
    - "Clicking agrupamento header toggles expand/collapse"
    - "Grid recalculates columns when agrupamento expands/collapses"
    - "Cells display 6 distinct heatmap colors based on verification status"
    - "Tooltip shows status label on hover for non-pending cells"
    - "Each service row shows progress fraction and mini progress bar"
    - "Color legend is visible on the page showing all 6 status colors"
    - "Clicking a cell with existing verification navigates to individual page"
    - "Clicking a pending cell navigates to /nova with query params"
  artifacts:
    - path: "arden/app/app/obras/[id]/verificacoes/page.tsx"
      provides: "Server Component that fetches matrix data and renders MatrizClient"
      min_lines: 15
    - path: "arden/app/app/obras/[id]/verificacoes/_components/matriz-client.tsx"
      provides: "Client orchestrator managing collapse state, visible units, and color legend"
      exports: ["MatrizClient"]
    - path: "arden/app/app/obras/[id]/verificacoes/_components/matriz-grid.tsx"
      provides: "CSS Grid container with sticky headers, z-index stacking, cell rendering, tooltips, progress, and event delegation"
      exports: ["MatrizGrid"]
    - path: "arden/app/app/obras/[id]/verificacoes/_components/matriz-header.tsx"
      provides: "Multi-level agrupamento and unit header components"
      exports: ["AgrupamentoHeaders", "UnitHeaders"]
  key_links:
    - from: "page.tsx"
      to: "getMatrizData"
      via: "Server-side fetch with await createClient()"
      pattern: "getMatrizData\\(supabase"
    - from: "page.tsx"
      to: "MatrizClient"
      via: "Passes initialData prop"
      pattern: "MatrizClient.*initialData"
    - from: "MatrizClient"
      to: "MatrizGrid"
      via: "Passes servicos, visibleUnits, expandedGroups, verificacoesMap"
    - from: "MatrizGrid"
      to: "CSS Grid display"
      via: "Inline style gridTemplateColumns with dynamic column count"
      pattern: "gridTemplateColumns.*repeat"
    - from: "MatrizGrid"
      to: "deriveMatrizCellStatus"
      via: "Import from matriz-status.ts to compute cell color"
      pattern: "deriveMatrizCellStatus"
    - from: "MatrizGrid cell click"
      to: "router.push"
      via: "Event delegation on grid container with data-cell attribute"
      pattern: "closest.*data-cell"
    - from: "sticky headers"
      to: "z-index hierarchy"
      via: "z-30 corner, z-20 headers, z-10 service column, z-0 data cells"
---

<objective>
Construir a página completa da Matriz de Verificações com grid CSS interativo, headers sticky multinível, agrupamentos colapsáveis, células com heatmap de 6 cores, tooltips, progresso por serviço, legenda de cores, e navegação por clique.

Purpose: Esta é a tela principal onde o engenheiro visualiza o estado de todas as verificações da obra em uma única tela. O grid CSS com sticky headers permite navegar obras com centenas de unidades sem perder contexto. Agrupamentos colapsáveis (Torres, Blocos) filtram a visualização para manter performance. As 6 cores do heatmap permitem avaliar a qualidade da obra inteira de relance.

Output: Página funcional em /app/obras/[id]/verificacoes implementando todos os 5 requisitos MATRZ-01 a MATRZ-05: matriz serviço x unidade, células com status visual, scroll com sticky, headers multinível, e progresso por serviço.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/CONVENTIONS.md
@.planning/phases/09-matriz-verificacoes/09-CONTEXT.md
@.planning/phases/09-matriz-verificacoes/09-RESEARCH.md
@.planning/phases/09-matriz-verificacoes/09-01-SUMMARY.md

Source files (read ALL before starting):
@arden/lib/supabase/queries/verificacoes.ts (MatrizData types + getMatrizData query)
@arden/app/app/obras/[id]/verificacoes/_components/matriz-status.ts (status utils created in 09-01)
@arden/app/app/biblioteca/page.tsx (template de página - padrão obrigatório)
@arden/components/ui/tooltip.tsx (tooltip component installed in 09-01)
@arden/components/ui/progress.tsx (Progress component from Radix)
@arden/app/globals.css (CSS variables for colors)
@arden/components/navigation/sidebar-obra.tsx (sidebar already has "Verificações" link to this route)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server Component page.tsx + Client Orchestrator com legenda e estado de colapso</name>
  <files>
    arden/app/app/obras/[id]/verificacoes/page.tsx
    arden/app/app/obras/[id]/verificacoes/_components/matriz-client.tsx
  </files>
  <action>
1. **Criar `page.tsx`** (Server Component) em `arden/app/app/obras/[id]/verificacoes/`:
   - Import `createClient` from `@/lib/supabase/server`
   - Import `getMatrizData` from `@/lib/supabase/queries/verificacoes`
   - Import `MatrizClient` from `./_components/matriz-client`
   - Interface PageProps com `params: Promise<{ id: string }>`
   - Await params para extrair `obraId`
   - Fetch `matrizData` via `getMatrizData(supabase, obraId)`
   - Render wrapper obrigatório: `div.p-6.bg-background.min-h-full` > `div.max-w-full.mx-auto`
   - Header: h1 "Verificações" (`text-2xl font-normal text-foreground`) + p "Matriz de verificações da obra" (`text-sm text-foreground-light mt-1`)
   - Render `<MatrizClient initialData={matrizData} obraId={obraId} />`
   - **IMPORTANTE:** Usar `max-w-full` (NÃO `max-w-6xl`) — a matriz precisa de toda a largura disponível

2. **Criar `matriz-client.tsx`** (Client Component) em `_components/`:
   - `'use client'` directive
   - Props interface: `{ initialData: MatrizData; obraId: string }`
   - Import types `MatrizData` from `@/lib/supabase/queries/verificacoes`
   - Import `MatrizGrid` from `./matriz-grid`
   - Import `STATUS_COLORS`, `STATUS_LABELS`, `MatrizCellStatus` from `./matriz-status`

   **Estado de colapso de agrupamentos:**
   ```typescript
   const { servicos, agrupamentos, verificacoesMap } = initialData

   const [expandedGroups, setExpandedGroups] = useState<Set<string>>(() => {
     // Default: primeiro agrupamento expandido
     if (agrupamentos.length > 0) {
       return new Set([agrupamentos[0].id])
     }
     return new Set()
   })

   const handleToggleGroup = useCallback((groupId: string) => {
     setExpandedGroups(prev => {
       const next = new Set(prev)
       if (next.has(groupId)) {
         next.delete(groupId)
       } else {
         next.add(groupId)
       }
       return next
     })
   }, [])
   ```

   **Cálculo de unidades visíveis e colunas totais:**
   ```typescript
   // Unidades visíveis = unidades de agrupamentos expandidos
   const visibleUnits = useMemo(() => {
     return agrupamentos.flatMap(ag =>
       expandedGroups.has(ag.id) ? ag.unidades : []
     )
   }, [agrupamentos, expandedGroups])

   // Total de colunas = unidades visíveis + 1 coluna placeholder por grupo collapsed
   const collapsedGroupCount = useMemo(() => {
     return agrupamentos.filter(ag => !expandedGroups.has(ag.id)).length
   }, [agrupamentos, expandedGroups])

   const totalDataColumns = visibleUnits.length + collapsedGroupCount
   ```

   **Empty state:**
   Se `servicos.length === 0` ou `agrupamentos.length === 0`, renderizar:
   ```tsx
   <div className="flex items-center justify-center py-16">
     <p className="text-foreground-light">
       Nenhum serviço ou unidade configurada nesta obra.
     </p>
   </div>
   ```

   **Legenda de cores** — renderizar acima do grid, alinhada à direita:
   ```tsx
   <div className="flex items-center gap-4 mb-4 flex-wrap justify-end">
     {(Object.entries(STATUS_COLORS) as [MatrizCellStatus, string][]).map(([status, colorClass]) => (
       <div key={status} className="flex items-center gap-1.5">
         <div className={`w-3 h-3 rounded-sm ${colorClass}`} />
         <span className="text-xs text-foreground-lighter">{STATUS_LABELS[status]}</span>
       </div>
     ))}
   </div>
   ```

   **Render MatrizGrid:**
   ```tsx
   <MatrizGrid
     servicos={servicos}
     visibleUnits={visibleUnits}
     agrupamentos={agrupamentos}
     expandedGroups={expandedGroups}
     verificacoesMap={verificacoesMap}
     onToggleGroup={handleToggleGroup}
     obraId={obraId}
     totalDataColumns={totalDataColumns}
   />
   ```

   - **NÃO usar Zustand** — estado de colapso é transiente de UI (decisão do projeto)
  </action>
  <verify>
  - `npm run build` compila sem erros
  - Acessar `/app/obras/[obraId]/verificacoes` renderiza a página sem erros no console
  - Header "Verificações" aparece na página
  - Legenda mostra 6 cores com labels em português
  - Se obra não tem serviços/unidades, mostra empty state
  </verify>
  <done>Página server component busca dados da matriz e passa para client orchestrator. Client orchestrator gerencia estado de colapso, calcula unidades visíveis, e renderiza legenda de cores com 6 status.</done>
</task>

<task type="auto">
  <name>Task 2: CSS Grid com sticky headers, células heatmap, tooltips, progresso e navegação</name>
  <files>
    arden/app/app/obras/[id]/verificacoes/_components/matriz-grid.tsx
    arden/app/app/obras/[id]/verificacoes/_components/matriz-header.tsx
  </files>
  <action>
1. **Criar `matriz-grid.tsx`** — componente principal do grid com React.memo:
   - `'use client'` directive
   - Import `React, { memo, useCallback, useMemo }` from 'react'
   - Import `useRouter` from `next/navigation`
   - Import `{ Tooltip, TooltipContent, TooltipTrigger, TooltipProvider }` from `@/components/ui/tooltip`
   - Import `{ Progress }` from `@/components/ui/progress`
   - Import `{ deriveMatrizCellStatus, STATUS_COLORS, STATUS_LABELS }` from `./matriz-status`
   - Import `{ AgrupamentoHeaders, UnitHeaders }` from `./matriz-header`
   - Import types `{ MatrizServico, MatrizUnidade, MatrizAgrupamento, MatrizVerificacao }` from `@/lib/supabase/queries/verificacoes`

   **Props interface:**
   ```typescript
   interface MatrizGridProps {
     servicos: MatrizServico[]
     visibleUnits: MatrizUnidade[]
     agrupamentos: MatrizAgrupamento[]
     expandedGroups: Set<string>
     verificacoesMap: Record<string, MatrizVerificacao>
     onToggleGroup: (groupId: string) => void
     obraId: string
     totalDataColumns: number
   }
   ```

   **Event delegation para cliques nas células:**
   ```typescript
   const router = useRouter()

   const handleClick = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
     const cell = (e.target as HTMLElement).closest('[data-cell]') as HTMLElement | null
     if (!cell) return

     const servicoId = cell.dataset.servicoId
     const unidadeId = cell.dataset.unidadeId
     if (!servicoId || !unidadeId) return

     const key = `${servicoId}:${unidadeId}`
     const verificacao = verificacoesMap[key]

     if (verificacao) {
       router.push(`/app/obras/${obraId}/verificacoes/${verificacao.id}`)
     } else {
       // Célula pendente: navegar sem criar verificação (proteção contra clique acidental)
       router.push(`/app/obras/${obraId}/verificacoes/nova?servico=${servicoId}&unidade=${unidadeId}`)
     }
   }, [verificacoesMap, obraId, router])
   ```

   **Layout do grid — ESTRUTURA COMPLETA:**

   ```tsx
   return (
     <div
       className="overflow-auto rounded-md border border-border"
       style={{ maxHeight: 'calc(100vh - 280px)' }}
     >
       <TooltipProvider delayDuration={200}>
         <div
           onClick={handleClick}
           style={{
             display: 'grid',
             gridTemplateColumns: `280px repeat(${totalDataColumns}, 40px)`,
             gridTemplateRows: `40px 32px repeat(${servicos.length}, 56px)`,
           }}
         >
           {/* 1. CORNER CELL — z-30, sticky top+left */}
           <div
             className="bg-surface-100 border-b border-r border-border flex items-end pb-1 pl-3"
             style={{
               position: 'sticky',
               top: 0,
               left: 0,
               zIndex: 30,
               gridRow: '1 / 3',
               gridColumn: '1',
             }}
           >
             <span className="text-xs font-medium text-foreground-lighter">Serviço</span>
           </div>

           {/* 2. AGRUPAMENTO HEADERS — z-20, sticky top:0 */}
           <AgrupamentoHeaders
             agrupamentos={agrupamentos}
             expandedGroups={expandedGroups}
             onToggle={onToggleGroup}
           />

           {/* 3. UNIT NAME HEADERS — z-20, sticky top:40px */}
           <UnitHeaders visibleUnits={visibleUnits} />

           {/* 4. SERVICE ROWS: name+progress (sticky left) + data cells */}
           {servicos.map((servico, rowIndex) => {
             // Calcular progresso para este serviço
             const verificadas = visibleUnits.filter(u =>
               verificacoesMap[`${servico.id}:${u.id}`]
             ).length
             const total = visibleUnits.length
             const pct = total > 0 ? (verificadas / total) * 100 : 0

             // Row index no grid: rowIndex + 3 (row 1=agrupamento, row 2=unidades, row 3+=serviços)
             const gridRow = rowIndex + 3

             return (
               <React.Fragment key={servico.id}>
                 {/* Service name cell — sticky left, z-10 */}
                 <div
                   className="bg-surface-100 border-b border-r border-border px-3 py-1 flex flex-col justify-center"
                   style={{
                     position: 'sticky',
                     left: 0,
                     zIndex: 10,
                     gridRow: gridRow,
                     gridColumn: '1',
                   }}
                 >
                   <span className="text-xs font-medium text-foreground truncate" title={servico.nome}>
                     {servico.nome}
                   </span>
                   <div className="flex items-center gap-2 mt-0.5">
                     <span className="text-[10px] text-foreground-lighter whitespace-nowrap">
                       {verificadas}/{total}
                     </span>
                     <Progress value={pct} className="h-0.5 w-16" />
                   </div>
                 </div>

                 {/* Data cells for this service row */}
                 {/* Iterar pelas colunas: para cada agrupamento, se expandido renderizar células de cada unidade, se collapsed renderizar célula vazia */}
                 {agrupamentos.map(ag => {
                   if (expandedGroups.has(ag.id)) {
                     // Expandido: render cell for each unit
                     return ag.unidades.map(unidade => {
                       const key = `${servico.id}:${unidade.id}`
                       const verificacao = verificacoesMap[key]
                       const cellStatus = deriveMatrizCellStatus(verificacao)
                       const colorClass = STATUS_COLORS[cellStatus]

                       const cellDiv = (
                         <div
                           key={`${servico.id}-${unidade.id}`}
                           data-cell=""
                           data-servico-id={servico.id}
                           data-unidade-id={unidade.id}
                           className={`${colorClass} cursor-pointer hover:opacity-80 transition-opacity border-r border-b border-border/30`}
                           style={{ gridRow }}
                         />
                       )

                       // Tooltip somente para células não-pendentes
                       if (cellStatus === 'pendente') return cellDiv

                       return (
                         <Tooltip key={`${servico.id}-${unidade.id}`}>
                           <TooltipTrigger asChild>
                             {cellDiv}
                           </TooltipTrigger>
                           <TooltipContent side="top" className="text-xs">
                             {STATUS_LABELS[cellStatus]}
                           </TooltipContent>
                         </Tooltip>
                       )
                     })
                   } else {
                     // Collapsed: render single empty placeholder cell
                     return (
                       <div
                         key={`collapsed-${ag.id}-${servico.id}`}
                         className="bg-surface-100/50 border-r border-b border-border/30"
                         style={{ gridRow }}
                       />
                     )
                   }
                 })}
               </React.Fragment>
             )
           })}
         </div>
       </TooltipProvider>
     </div>
   )
   ```

   **Wrap com `export const MatrizGrid = memo(function MatrizGrid(...) { ... })`**

   **AVISOS CRÍTICOS (da Research — Pitfalls a evitar):**
   - Pitfall 1: NÃO adicionar `overflow-hidden` em nenhum div entre o scroll container e os sticky elements. Isso quebra sticky.
   - Pitfall 2: TODOS sticky elements DEVEM ter `bg-surface-100` (background opaco). Sem background opaco, conteúdo scrollado aparece por trás.
   - Pitfall 4: Usar `React.memo` no `MatrizGrid`. Considerar `React.memo` também em sub-components se performance for problema.
   - Pitfall 6: Usar UM `<TooltipProvider delayDuration={200}>` envolvendo todo o grid. NÃO envolver cada tooltip individualmente com TooltipProvider.

2. **Criar `matriz-header.tsx`** — headers multinível colapsáveis:
   - `'use client'` directive
   - Import `ChevronRight` from `lucide-react`
   - Import types necessários

   **AgrupamentoHeaders component:**
   ```typescript
   interface AgrupamentoHeadersProps {
     agrupamentos: MatrizAgrupamento[]
     expandedGroups: Set<string>
     onToggle: (id: string) => void
   }

   export function AgrupamentoHeaders({ agrupamentos, expandedGroups, onToggle }: AgrupamentoHeadersProps) {
     // Calcular posição de cada agrupamento no grid
     // Col 1 é serviço. Cols 2+ são dados.
     // Para cada agrupamento em ordem: se expandido, ocupa N colunas (= suas unidades). Se collapsed, ocupa 1 coluna.
     let currentCol = 2 // começa na col 2 (col 1 é corner/serviço)

     return (
       <>
         {agrupamentos.map(ag => {
           const isExpanded = expandedGroups.has(ag.id)
           const span = isExpanded ? ag.unidades.length : 1
           const startCol = currentCol
           currentCol += span

           return (
             <div
               key={ag.id}
               className="bg-surface-100 border-b border-r border-border flex items-center gap-1 px-2 cursor-pointer hover:bg-surface-200 select-none"
               style={{
                 position: 'sticky',
                 top: 0,
                 zIndex: 20,
                 gridRow: '1',
                 gridColumn: `${startCol} / span ${span}`,
               }}
               onClick={() => onToggle(ag.id)}
             >
               <ChevronRight
                 className={`w-3 h-3 shrink-0 transition-transform ${isExpanded ? 'rotate-90' : ''}`}
               />
               <span className="text-xs font-medium text-foreground-light truncate">
                 {ag.nome}
               </span>
             </div>
           )
         })}
       </>
     )
   }
   ```

   **UnitHeaders component:**
   ```typescript
   interface UnitHeadersProps {
     visibleUnits: MatrizUnidade[]
   }

   export function UnitHeaders({ visibleUnits }: UnitHeadersProps) {
     // Nota: as unidades visíveis correspondem às colunas expandidas.
     // Colunas collapsed não têm unit headers (ficam vazias na row 2).
     // O posicionamento correto no grid é calculado por coluna absoluta.
     // Para simplificar, renderizar colunas vazias para grupos collapsed
     // é tratado no grid principal. Aqui, só renderizar os unit headers.
     // O grid CSS auto-posiciona as cells sequencialmente, mas precisamos
     // calcular gridColumn explicitamente se houver gaps de grupos collapsed.

     // Abordagem: receber as colunas como array linear e calcular gridColumn
     // Ou: usar auto-flow e deixar o grid posicionar naturalmente
     // Melhor: deixar o MatrizGrid posicionar os unit headers junto com
     // os collapsed placeholders. Mover essa lógica para o grid.

     // Abordagem simples: este componente renderiza os headers das unidades
     // e o grid principal intercala as cells placeholder de collapsed groups.
     // Ou, mover tudo para o grid.

     // DECISÃO: Renderizar unit headers aqui e deixar o MatrizGrid intercalar.
     // Os unit headers são posicionados pelo auto-flow do grid (row 2, sequential).
     return (
       <>
         {visibleUnits.map((unidade) => (
           <div
             key={unidade.id}
             className="bg-surface-100 border-b border-r border-border flex items-center justify-center"
             style={{
               position: 'sticky',
               top: 40,
               zIndex: 20,
               gridRow: '2',
             }}
           >
             <span className="text-[10px] text-foreground-lighter text-center leading-tight">
               {unidade.nome}
             </span>
           </div>
         ))}
       </>
     )
   }
   ```

   **IMPORTANTE — Intercalar headers de unidades com placeholders de collapsed groups:**
   O `UnitHeaders` renderiza apenas unidades visíveis. Mas o grid precisa de cells na row 2 para TODAS as colunas (inclusive collapsed placeholders). A solução é: no `MatrizGrid`, após renderizar `<UnitHeaders>`, renderizar divs placeholder vazios na row 2 para cada grupo collapsed. OU, refatorar para que a row 2 seja renderizada diretamente no grid iterando por agrupamentos (se expandido, render unit headers; se collapsed, render empty cell).

   **Abordagem recomendada para row 2:** Iterar agrupamentos no `MatrizGrid` para a row 2:
   - Se grupo expandido: renderizar uma cell por unidade (nome)
   - Se grupo collapsed: renderizar uma cell vazia (placeholder)
   - Isso garante posicionamento correto sem gaps

   Nesse caso, `UnitHeaders` pode ser uma função simples chamada pelo grid, ou a lógica vive diretamente no grid. **Claude decide a decomposição final**, mas a lógica deve estar correta: cada coluna no grid tem correspondente na row 2.

  </action>
  <verify>
  - `npm run build` compila sem erros
  - Acessar a página da matriz mostra o grid com serviços à esquerda e unidades no topo
  - Scroll horizontal mantém coluna de serviços fixa (sticky left funciona)
  - Scroll vertical mantém headers fixos (sticky top funciona)
  - Corner cell com label "Serviço" fica acima de tudo durante scroll diagonal
  - Clicar no header de agrupamento colapsa/expande as unidades
  - Chevron rotaciona ao expandir/colapsar
  - Primeiro agrupamento está expandido por padrão, demais collapsed
  - Células mostram cores corretas do heatmap (6 cores distintas)
  - Tooltip aparece ao hover em células não-pendentes, mostrando nome do status
  - Progresso (ex: "5/20" + mini barra verde) aparece em cada linha de serviço
  - Clicar em célula com verificação existente navega para /verificacoes/[id]
  - Clicar em célula pendente navega para /verificacoes/nova?servico=X&unidade=Y
  </verify>
  <done>Grid CSS da matriz renderiza com headers sticky multinível, agrupamentos colapsáveis, células com heatmap de 6 cores, tooltips, progresso por serviço, e navegação por clique. Todos os 5 requisitos MATRZ-01 a MATRZ-05 implementados.</done>
</task>

</tasks>

<verification>
1. Página carrega em /app/obras/[obraId]/verificacoes sem erros
2. Grid mostra serviços nas linhas e unidades nas colunas
3. Sticky headers funcionam em scroll horizontal E vertical simultaneamente
4. Corner cell sobrepõe tudo durante scroll diagonal
5. Agrupamentos colapsáveis: clicar no header toggle expand/collapse
6. Primeiro agrupamento expandido por padrão, demais collapsed
7. Cells renderizam com as 6 cores corretas (pendente=surface, conforme=verde, NC=vermelho, exceção=âmbar, conforme_reinspecao=verde claro, nc_reinspecao=vermelho claro)
8. Tooltip no hover mostra label do status em português
9. Progresso (ex: "5/20" + mini barra) aparece em cada serviço
10. Legenda de cores visível acima do grid com 6 status
11. Click em célula com verificação navega para página individual
12. Click em célula pendente navega para /nova com query params
13. Empty state quando obra não tem serviços ou unidades
14. `npm run build` sem erros
</verification>

<success_criteria>
- MATRZ-01: Página de verificações com matriz serviço x unidade — grid CSS com serviços nas linhas e unidades nas colunas
- MATRZ-02: Células com status visual (cor heatmap) para cada par serviço/unidade — 6 cores distintas
- MATRZ-03: Scroll horizontal com coluna de serviço fixa e header fixo — sticky left + sticky top com z-index 3 níveis
- MATRZ-04: Colunas agrupadas por agrupamento com headers multinível — header nível 1 (agrupamento) + nível 2 (unidades)
- MATRZ-05: Indicador de progresso por serviço (fração + mini barra) — texto "X/Y" + Progress component
</success_criteria>

<output>
After completion, create `.planning/phases/09-matriz-verificacoes/09-02-SUMMARY.md`
</output>
