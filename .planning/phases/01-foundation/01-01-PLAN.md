---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - arden/package.json
  - arden/lib/stores/app-store.ts
  - arden/lib/stores/store-provider.tsx
  - arden/lib/stores/index.ts
  - arden/app/app/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Zustand store pode armazenar e atualizar estado global da aplicacao"
    - "Componentes podem consumir estado via useAppStore hook"
    - "Estado nao vaza entre requests no App Router (per-request isolation)"
  artifacts:
    - path: "arden/lib/stores/app-store.ts"
      provides: "Store factory com UI state (sidebarOpen, currentObraId)"
      exports: ["createAppStore", "AppState", "AppStore"]
    - path: "arden/lib/stores/store-provider.tsx"
      provides: "Context provider e hook useAppStore"
      exports: ["StoreProvider", "useAppStore"]
    - path: "arden/lib/stores/index.ts"
      provides: "Re-export de todos os stores"
      exports: ["*"]
  key_links:
    - from: "arden/app/app/layout.tsx"
      to: "arden/lib/stores/store-provider.tsx"
      via: "StoreProvider wrapping children"
      pattern: "<StoreProvider>"
    - from: "arden/lib/stores/store-provider.tsx"
      to: "arden/lib/stores/app-store.ts"
      via: "createAppStore call"
      pattern: "createAppStore"
---

<objective>
Configurar Zustand para state management global no Arden FVS.

Purpose: Estabelecer infraestrutura de estado global que sera usada em todas as features subsequentes (sidebar, currentObra, loading states).

Output: Store funcional com provider integrado ao layout da aplicacao.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md

# Codebase context
@arden/app/app/layout.tsx
@arden/lib/utils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Instalar Zustand e criar app-store</name>
  <files>
    arden/package.json
    arden/lib/stores/app-store.ts
    arden/lib/stores/index.ts
  </files>
  <action>
1. Instalar zustand:
   ```bash
   cd arden && npm install zustand@^5.0.10
   ```

2. Criar diretorio `arden/lib/stores/`

3. Criar `arden/lib/stores/app-store.ts`:
   - Usar `createStore` do `zustand/vanilla` (NAO `create` - padrao App Router)
   - Importar `devtools` do `zustand/middleware`
   - Interface AppState com:
     - `sidebarOpen: boolean` (default: true)
     - `currentObraId: string | null` (default: null)
     - `isLoading: boolean` (default: false)
   - Actions:
     - `toggleSidebar: () => void`
     - `setSidebarOpen: (open: boolean) => void`
     - `setCurrentObra: (obraId: string | null) => void`
     - `setLoading: (loading: boolean) => void`
   - Factory function `createAppStore(initialState?)` retornando store configurado
   - Devtools habilitado apenas em development
   - Exportar tipos: `AppState`, `AppStore`

4. Criar `arden/lib/stores/index.ts`:
   - Re-exportar tudo de `./app-store`
   - Preparar para futuros stores

Seguir exatamente o padrao do RESEARCH.md (Pattern 1: Per-Request Store with Context Provider).
  </action>
  <verify>
    - `npm ls zustand` mostra versao 5.x instalada
    - Arquivo `arden/lib/stores/app-store.ts` existe e exporta `createAppStore`
    - TypeScript compila sem erros: `cd arden && npx tsc --noEmit`
  </verify>
  <done>
    Zustand instalado e app-store criado com interface tipada e factory function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Criar StoreProvider e integrar no layout</name>
  <files>
    arden/lib/stores/store-provider.tsx
    arden/lib/stores/index.ts
    arden/app/app/layout.tsx
  </files>
  <action>
1. Criar `arden/lib/stores/store-provider.tsx`:
   - Marcar como 'use client' (obrigatorio para Context)
   - Criar AppStoreContext com `createContext<AppStore | null>(null)`
   - Componente StoreProvider:
     - Props: `children: ReactNode`, `initialState?: Partial<AppState>`
     - Usar `useRef` para manter store instance estavel
     - Criar store apenas uma vez no ref
     - Retornar Provider com store como value
   - Hook `useAppStore<T>(selector: (state: AppState) => T): T`:
     - Obter store do context
     - Throw error se usado fora do provider
     - Usar `useStore` do zustand para aplicar selector
   - Exportar: `StoreProvider`, `useAppStore`

2. Atualizar `arden/lib/stores/index.ts`:
   - Adicionar re-export de `./store-provider`

3. Modificar `arden/app/app/layout.tsx`:
   - Importar `StoreProvider` de `@/lib/stores`
   - Envolver o conteudo do layout com `<StoreProvider>`
   - Manter estrutura existente (sidebar, main area)

O provider deve envolver apenas o conteudo interno, nao o HTML/body (que ja estao no root layout).
  </action>
  <verify>
    - `cd arden && npm run build` completa sem erros
    - `cd arden && npm run dev` inicia sem erros
    - Acessar http://localhost:3000/app nao mostra erros no console
  </verify>
  <done>
    StoreProvider criado e integrado ao layout. Zustand pronto para uso em qualquer componente dentro de /app/*.
  </done>
</task>

</tasks>

<verification>
Verificacao final da infraestrutura Zustand:

1. **Estrutura de arquivos:**
   ```
   arden/lib/stores/
   ├── app-store.ts      # Store factory e tipos
   ├── store-provider.tsx # Context provider e hook
   └── index.ts           # Re-exports
   ```

2. **Teste de integracao:**
   - Criar componente temporario que usa `useAppStore`
   - Verificar que estado pode ser lido e atualizado
   - Verificar que nao ha erros de hydration

3. **Build check:**
   - `npm run build` passa
   - `npm run lint` passa (se configurado)
</verification>

<success_criteria>
- [ ] Zustand 5.x instalado no package.json
- [ ] app-store.ts exporta createAppStore, AppState, AppStore
- [ ] store-provider.tsx exporta StoreProvider, useAppStore
- [ ] Layout do app envolvido com StoreProvider
- [ ] Build passa sem erros
- [ ] Dev server inicia sem erros de hydration
</success_criteria>

<output>
Apos conclusao, criar `.planning/phases/01-foundation/01-01-SUMMARY.md` seguindo o template.
</output>
